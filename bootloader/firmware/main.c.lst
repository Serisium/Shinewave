GAS LISTING /tmp/cc4tR2OR.s 			page 1


   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/garrett/git/shinewave/bootloader/firmware/",100,0,2,.Ltext0
   8               		.stabs	"main.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=r(0,2);0;127;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"__int128:t(0,6)=@s128;r(0,6);02000000000000000000000000000000000000000000;0177777777777777
  18               		.stabs	"__int128 unsigned:t(0,7)=@s128;r(0,7);0;03777777777777777777777777777777777777777777;",128
  19               		.stabs	"long long int:t(0,8)=@s64;r(0,8);01000000000000000000000;00777777777777777777777;",128,0,0
  20               		.stabs	"long long unsigned int:t(0,9)=@s64;r(0,9);0;01777777777777777777777;",128,0,0,0
  21               		.stabs	"short int:t(0,10)=r(0,10);-32768;32767;",128,0,0,0
  22               		.stabs	"short unsigned int:t(0,11)=r(0,11);0;0177777;",128,0,0,0
  23               		.stabs	"signed char:t(0,12)=@s8;r(0,12);-128;127;",128,0,0,0
  24               		.stabs	"unsigned char:t(0,13)=@s8;r(0,13);0;255;",128,0,0,0
  25               		.stabs	"float:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"double:t(0,15)=r(0,1);4;0;",128,0,0,0
  27               		.stabs	"long double:t(0,16)=r(0,1);4;0;",128,0,0,0
  28               		.stabs	"short _Fract:t(0,17)=r(0,1);1;0;",128,0,0,0
  29               		.stabs	"_Fract:t(0,18)=r(0,1);2;0;",128,0,0,0
  30               		.stabs	"long _Fract:t(0,19)=r(0,1);4;0;",128,0,0,0
  31               		.stabs	"long long _Fract:t(0,20)=r(0,1);8;0;",128,0,0,0
  32               		.stabs	"unsigned short _Fract:t(0,21)=r(0,1);1;0;",128,0,0,0
  33               		.stabs	"unsigned _Fract:t(0,22)=r(0,1);2;0;",128,0,0,0
  34               		.stabs	"unsigned long _Fract:t(0,23)=r(0,1);4;0;",128,0,0,0
  35               		.stabs	"unsigned long long _Fract:t(0,24)=r(0,1);8;0;",128,0,0,0
  36               		.stabs	"_Sat short _Fract:t(0,25)=r(0,1);1;0;",128,0,0,0
  37               		.stabs	"_Sat _Fract:t(0,26)=r(0,1);2;0;",128,0,0,0
  38               		.stabs	"_Sat long _Fract:t(0,27)=r(0,1);4;0;",128,0,0,0
  39               		.stabs	"_Sat long long _Fract:t(0,28)=r(0,1);8;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned short _Fract:t(0,29)=r(0,1);1;0;",128,0,0,0
  41               		.stabs	"_Sat unsigned _Fract:t(0,30)=r(0,1);2;0;",128,0,0,0
  42               		.stabs	"_Sat unsigned long _Fract:t(0,31)=r(0,1);4;0;",128,0,0,0
  43               		.stabs	"_Sat unsigned long long _Fract:t(0,32)=r(0,1);8;0;",128,0,0,0
  44               		.stabs	"short _Accum:t(0,33)=r(0,1);2;0;",128,0,0,0
  45               		.stabs	"_Accum:t(0,34)=r(0,1);4;0;",128,0,0,0
  46               		.stabs	"long _Accum:t(0,35)=r(0,1);8;0;",128,0,0,0
  47               		.stabs	"long long _Accum:t(0,36)=r(0,1);8;0;",128,0,0,0
  48               		.stabs	"unsigned short _Accum:t(0,37)=r(0,1);2;0;",128,0,0,0
  49               		.stabs	"unsigned _Accum:t(0,38)=r(0,1);4;0;",128,0,0,0
  50               		.stabs	"unsigned long _Accum:t(0,39)=r(0,1);8;0;",128,0,0,0
  51               		.stabs	"unsigned long long _Accum:t(0,40)=r(0,1);8;0;",128,0,0,0
  52               		.stabs	"_Sat short _Accum:t(0,41)=r(0,1);2;0;",128,0,0,0
  53               		.stabs	"_Sat _Accum:t(0,42)=r(0,1);4;0;",128,0,0,0
  54               		.stabs	"_Sat long _Accum:t(0,43)=r(0,1);8;0;",128,0,0,0
  55               		.stabs	"_Sat long long _Accum:t(0,44)=r(0,1);8;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned short _Accum:t(0,45)=r(0,1);2;0;",128,0,0,0
  57               		.stabs	"_Sat unsigned _Accum:t(0,46)=r(0,1);4;0;",128,0,0,0
GAS LISTING /tmp/cc4tR2OR.s 			page 2


  58               		.stabs	"_Sat unsigned long _Accum:t(0,47)=r(0,1);8;0;",128,0,0,0
  59               		.stabs	"_Sat unsigned long long _Accum:t(0,48)=r(0,1);8;0;",128,0,0,0
  60               		.stabs	"void:t(0,49)=(0,49)",128,0,0,0
  61               		.stabs	"/usr/avr/include/avr/io.h",130,0,0,0
  62               		.stabs	"/usr/avr/include/avr/sfr_defs.h",130,0,0,0
  63               		.stabs	"/usr/avr/include/inttypes.h",130,0,0,0
  64               		.stabs	"/usr/lib/gcc/avr/5.3.0/include/stdint.h",130,0,0,0
  65               		.stabs	"/usr/avr/include/stdint.h",130,0,0,0
  66               		.stabs	"int8_t:t(5,1)=(0,12)",128,0,125,0
  67               		.stabs	"uint8_t:t(5,2)=(0,13)",128,0,126,0
  68               		.stabs	"int16_t:t(5,3)=(0,1)",128,0,127,0
  69               		.stabs	"uint16_t:t(5,4)=(0,4)",128,0,128,0
  70               		.stabs	"int32_t:t(5,5)=(0,3)",128,0,129,0
  71               		.stabs	"uint32_t:t(5,6)=(0,5)",128,0,130,0
  72               		.stabs	"int64_t:t(5,7)=(0,8)",128,0,132,0
  73               		.stabs	"uint64_t:t(5,8)=(0,9)",128,0,133,0
  74               		.stabs	"intptr_t:t(5,9)=(5,3)",128,0,146,0
  75               		.stabs	"uintptr_t:t(5,10)=(5,4)",128,0,151,0
  76               		.stabs	"int_least8_t:t(5,11)=(5,1)",128,0,163,0
  77               		.stabs	"uint_least8_t:t(5,12)=(5,2)",128,0,168,0
  78               		.stabs	"int_least16_t:t(5,13)=(5,3)",128,0,173,0
  79               		.stabs	"uint_least16_t:t(5,14)=(5,4)",128,0,178,0
  80               		.stabs	"int_least32_t:t(5,15)=(5,5)",128,0,183,0
  81               		.stabs	"uint_least32_t:t(5,16)=(5,6)",128,0,188,0
  82               		.stabs	"int_least64_t:t(5,17)=(5,7)",128,0,196,0
  83               		.stabs	"uint_least64_t:t(5,18)=(5,8)",128,0,203,0
  84               		.stabs	"int_fast8_t:t(5,19)=(5,1)",128,0,217,0
  85               		.stabs	"uint_fast8_t:t(5,20)=(5,2)",128,0,222,0
  86               		.stabs	"int_fast16_t:t(5,21)=(5,3)",128,0,227,0
  87               		.stabs	"uint_fast16_t:t(5,22)=(5,4)",128,0,232,0
  88               		.stabs	"int_fast32_t:t(5,23)=(5,5)",128,0,237,0
  89               		.stabs	"uint_fast32_t:t(5,24)=(5,6)",128,0,242,0
  90               		.stabs	"int_fast64_t:t(5,25)=(5,7)",128,0,250,0
  91               		.stabs	"uint_fast64_t:t(5,26)=(5,8)",128,0,257,0
  92               		.stabs	"intmax_t:t(5,27)=(5,7)",128,0,277,0
  93               		.stabs	"uintmax_t:t(5,28)=(5,8)",128,0,282,0
  94               		.stabn	162,0,0,0
  95               		.stabn	162,0,0,0
  96               		.stabs	"int_farptr_t:t(3,1)=(5,5)",128,0,77,0
  97               		.stabs	"uint_farptr_t:t(3,2)=(5,6)",128,0,81,0
  98               		.stabn	162,0,0,0
  99               		.stabn	162,0,0,0
 100               		.stabs	"/usr/avr/include/avr/fuse.h",130,0,0,0
 101               		.stabs	"__fuse_t:t(6,1)=(6,2)=s3low:(0,13),0,8;high:(0,13),8,8;extended:(0,13),16,8;;",128,0,244,0
 102               		.stabn	162,0,0,0
 103               		.stabn	162,0,0,0
 104               		.stabs	"/usr/avr/include/avr/pgmspace.h",130,0,0,0
 105               		.stabs	"/usr/lib/gcc/avr/5.3.0/include/stddef.h",130,0,0,0
 106               		.stabs	"size_t:t(8,1)=(0,4)",128,0,216,0
 107               		.stabn	162,0,0,0
 108               		.stabn	162,0,0,0
 109               		.stabs	"/usr/avr/include/avr/boot.h",130,0,0,0
 110               		.stabs	"/usr/avr/include/avr/eeprom.h",130,0,0,0
 111               		.stabs	"/usr/lib/gcc/avr/5.3.0/include/stddef.h",130,0,0,0
 112               		.stabs	"ptrdiff_t:t(11,1)=(0,1)",128,0,149,0
 113               		.stabs	"wchar_t:t(11,2)=(0,1)",128,0,328,0
 114               		.stabs	"max_align_t:t(11,3)=(11,4)=s12__max_align_ll:(0,8),0,64;__max_align_ld:(0,16),64,32;;",128
GAS LISTING /tmp/cc4tR2OR.s 			page 3


 115               		.stabn	162,0,0,0
 116               		.stabn	162,0,0,0
 117               		.stabn	162,0,0,0
 118               		.stabs	"usbdrv/usbdrv.c",130,0,0,0
 119               		.stabs	"usbdrv/usbdrv.h",130,0,0,0
 120               		.stabs	"usbTxStatus:T(13,1)=s12len:(13,2)=B(0,13),0,8;buffer:(13,3)=ar(13,4)=r(13,4);0;0177777;;0;
 121               		.stabs	"usbTxStatus_t:t(13,5)=(13,1)",128,0,660,0
 122               		.stabs	"usbWord:T(13,6)=u2word:(0,4),0,16;bytes:(13,7)=ar(13,4);0;1;(0,13),0,16;;",128,0,0,0
 123               		.stabs	"usbWord_t:t(13,8)=(13,6)",128,0,672,0
 124               		.stabs	"usbRequest:T(13,9)=s8bmRequestType:(0,13),0,8;bRequest:(0,13),8,8;wValue:(13,8),16,16;wInd
 125               		.stabs	"usbRequest_t:t(13,10)=(13,9)",128,0,680,0
 126               		.stabn	162,0,0,0
 127               		.stabn	162,0,0,0
 128               		.stabs	"uint16_union_t:t(0,50)=(0,51)=u2w:(5,4),0,16;b:(0,52)=ar(13,4);0;1;(5,2),0,16;;",128,0,68,
 129               		.stabs	" :T(0,53)=ecmd_local_nop:0,cmd_device_info:0,cmd_transfer_page:1,cmd_erase_application:2,c
 130               		.section	.text.writeWordToPageBuffer,"ax",@progbits
 131               		.stabs	"writeWordToPageBuffer:f(0,49)",36,0,137,writeWordToPageBuffer
 132               		.stabs	"data:P(5,4)",64,0,137,24
 133               		.type	writeWordToPageBuffer, @function
 134               	writeWordToPageBuffer:
 135               		.stabd	46,0,0
   1:main.c        **** /* 
   2:main.c        ****  * Project: Micronucleus -  v2.1
   3:main.c        ****  *
   4:main.c        ****  * Micronucleus V2.1             (c) 2015 Tim Bo"scke - cpldcpu@gmail.com
   5:main.c        ****  *                               (c) 2014 Shay Green
   6:main.c        ****  * Original Micronucleus         (c) 2012 Jenna Fox
   7:main.c        ****  *
   8:main.c        ****  * Based on USBaspLoader-tiny85  (c) 2012 Louis Beaudoin
   9:main.c        ****  * Based on USBaspLoader         (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
  10:main.c        ****  *
  11:main.c        ****  * License: GNU GPL v2 (see License.txt)
  12:main.c        ****  */
  13:main.c        ****  
  14:main.c        **** #define MICRONUCLEUS_VERSION_MAJOR 2
  15:main.c        **** #define MICRONUCLEUS_VERSION_MINOR 1
  16:main.c        **** 
  17:main.c        **** #include <avr/io.h>
  18:main.c        **** #include <avr/pgmspace.h>
  19:main.c        **** #include <avr/wdt.h>
  20:main.c        **** #include <avr/boot.h>
  21:main.c        **** #include <util/delay.h>
  22:main.c        **** 
  23:main.c        **** #include "bootloaderconfig.h"
  24:main.c        **** #include "usbdrv/usbdrv.c"
  25:main.c        **** 
  26:main.c        **** // verify the bootloader address aligns with page size
  27:main.c        **** #if (defined __AVR_ATtiny841__)||(defined __AVR_ATtiny441__)  
  28:main.c        ****   #if BOOTLOADER_ADDRESS % ( SPM_PAGESIZE * 4 ) != 0
  29:main.c        ****     #error "BOOTLOADER_ADDRESS in makefile must be a multiple of chip's pagesize"
  30:main.c        ****   #endif
  31:main.c        **** #else
  32:main.c        ****   #if BOOTLOADER_ADDRESS % SPM_PAGESIZE != 0
  33:main.c        ****     #error "BOOTLOADER_ADDRESS in makefile must be a multiple of chip's pagesize"
  34:main.c        ****   #endif  
  35:main.c        **** #endif
  36:main.c        **** 
GAS LISTING /tmp/cc4tR2OR.s 			page 4


  37:main.c        **** #if SPM_PAGESIZE>256
  38:main.c        ****   #error "Micronucleus only supports pagesizes up to 256 bytes"
  39:main.c        **** #endif
  40:main.c        **** 
  41:main.c        **** #if ((AUTO_EXIT_MS>0) && (AUTO_EXIT_MS<1000))
  42:main.c        ****   #error "Do not set AUTO_EXIT_MS to below 1s to allow Micronucleus to function properly"
  43:main.c        **** #endif
  44:main.c        **** 
  45:main.c        **** // Device configuration reply
  46:main.c        **** // Length: 6 bytes
  47:main.c        **** //   Byte 0:  User program memory size, high byte
  48:main.c        **** //   Byte 1:  User program memory size, low byte   
  49:main.c        **** //   Byte 2:  Flash Pagesize in bytes
  50:main.c        **** //   Byte 3:  Page write timing in ms. 
  51:main.c        **** //    Bit 7 '0': Page erase time equals page write time
  52:main.c        **** //    Bit 7 '1': Page erase time equals page write time divided by 4
  53:main.c        **** //   Byte 4:  SIGNATURE_1
  54:main.c        **** //   Byte 5:  SIGNATURE_2 
  55:main.c        **** 
  56:main.c        **** PROGMEM const uint8_t configurationReply[6] = {
  57:main.c        ****   (((uint16_t)PROGMEM_SIZE) >> 8) & 0xff,
  58:main.c        ****   ((uint16_t)PROGMEM_SIZE) & 0xff,
  59:main.c        ****   SPM_PAGESIZE,
  60:main.c        ****   MICRONUCLEUS_WRITE_SLEEP,
  61:main.c        ****   SIGNATURE_1,
  62:main.c        ****   SIGNATURE_2
  63:main.c        **** };  
  64:main.c        **** 
  65:main.c        ****   typedef union {
  66:main.c        ****     uint16_t w;
  67:main.c        ****     uint8_t b[2];
  68:main.c        ****   } uint16_union_t;
  69:main.c        ****   
  70:main.c        **** #if OSCCAL_RESTORE_DEFAULT
  71:main.c        ****   register uint8_t      osccal_default  asm("r2");
  72:main.c        **** #endif 
  73:main.c        **** 
  74:main.c        **** register uint16_union_t currentAddress  asm("r4");  // r4/r5 current progmem address, used for eras
  75:main.c        **** register uint16_union_t idlePolls       asm("r6");  // r6/r7 idlecounter
  76:main.c        **** 
  77:main.c        **** // command system schedules functions to run in the main loop
  78:main.c        **** enum {
  79:main.c        ****   cmd_local_nop=0, 
  80:main.c        ****   cmd_device_info=0,
  81:main.c        ****   cmd_transfer_page=1,
  82:main.c        ****   cmd_erase_application=2,
  83:main.c        ****   cmd_write_data=3,
  84:main.c        ****   cmd_exit=4,
  85:main.c        ****   cmd_write_page=64  // internal commands start at 64
  86:main.c        **** };
  87:main.c        **** register uint8_t        command         asm("r3");  // bind command to r3 
  88:main.c        **** 
  89:main.c        **** // Definition of sei and cli without memory barrier keyword to prevent reloading of memory variable
  90:main.c        **** #define sei() asm volatile("sei")
  91:main.c        **** #define cli() asm volatile("cli")
  92:main.c        **** #define nop() asm volatile("nop")
  93:main.c        **** #define wdr() asm volatile("wdr")
GAS LISTING /tmp/cc4tR2OR.s 			page 5


  94:main.c        **** 
  95:main.c        **** // Use the old delay routines without NOP padding. This saves memory.
  96:main.c        **** #define __DELAY_BACKWARD_COMPATIBLE__   
  97:main.c        **** 
  98:main.c        **** /* ------------------------------------------------------------------------ */
  99:main.c        **** static inline void eraseApplication(void);
 100:main.c        **** static void writeFlashPage(void);
 101:main.c        **** static void writeWordToPageBuffer(uint16_t data);
 102:main.c        **** static uint8_t usbFunctionSetup(uint8_t data[8]);
 103:main.c        **** static inline void leaveBootloader(void);
 104:main.c        **** 
 105:main.c        **** // This function is never called, it is just here to suppress a compiler warning.
 106:main.c        **** USB_PUBLIC usbMsgLen_t usbFunctionDescriptor(struct usbRequest *rq) { return 0; }
 107:main.c        **** 
 108:main.c        **** // erase all pages until bootloader, in reverse order (so our vectors stay in place for as long as 
 109:main.c        **** // to minimise the chance of leaving the device in a state where the bootloader wont run, if there'
 110:main.c        **** // during upload
 111:main.c        **** static inline void eraseApplication(void) {
 112:main.c        ****   uint16_t ptr = BOOTLOADER_ADDRESS;
 113:main.c        **** 
 114:main.c        ****   while (ptr) {
 115:main.c        **** #if (defined __AVR_ATtiny841__)||(defined __AVR_ATtiny441__)    
 116:main.c        ****     ptr -= SPM_PAGESIZE * 4;        
 117:main.c        **** #else
 118:main.c        ****     ptr -= SPM_PAGESIZE;        
 119:main.c        **** #endif    
 120:main.c        ****     boot_page_erase(ptr);
 121:main.c        ****   }
 122:main.c        ****   
 123:main.c        ****   // Reset address to ensure the reset vector is written first.
 124:main.c        ****   currentAddress.w = 0;   
 125:main.c        **** }
 126:main.c        **** 
 127:main.c        **** // simply write currently stored page in to already erased flash memory
 128:main.c        **** static inline void writeFlashPage(void) {
 129:main.c        ****   if (currentAddress.w - 2 <BOOTLOADER_ADDRESS)
 130:main.c        ****       boot_page_write(currentAddress.w - 2);   // will halt CPU, no waiting required
 131:main.c        **** }
 132:main.c        **** 
 133:main.c        **** // Write a word into the page buffer.
 134:main.c        **** // Will patch the bootloader reset vector into the main vectortable to ensure
 135:main.c        **** // the device can not be bricked. Saving user-reset-vector is done in the host 
 136:main.c        **** // tool, starting with firmware V2
 137:main.c        **** static void writeWordToPageBuffer(uint16_t data) {
 136               		.stabn	68,0,137,.LM0-.LFBB1
 137               	.LM0:
 138               	.LFBB1:
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 141               	/* stack size = 0 */
 142               	.L__stack_usage = 0
 138:main.c        **** 
 139:main.c        **** #ifndef ENABLE_UNSAFE_OPTIMIZATIONS     
 140:main.c        ****   #if BOOTLOADER_ADDRESS < 8192
 141:main.c        ****   // rjmp
 142:main.c        ****   if (currentAddress.w == RESET_VECTOR_OFFSET * 2) {
 143               		.stabn	68,0,142,.LM1-.LFBB1
GAS LISTING /tmp/cc4tR2OR.s 			page 6


 144               	.LM1:
 145 0000 F201      		movw r30,r4
 146 0002 3097      		sbiw r30,0
 147 0004 01F4      		brne .L2
 143:main.c        ****     data = 0xC000 + (BOOTLOADER_ADDRESS/2) - 1;
 148               		.stabn	68,0,143,.LM2-.LFBB1
 149               	.LM2:
 150 0006 8FE1      		ldi r24,lo8(31)
 151 0008 9DEC      		ldi r25,lo8(-51)
 152               	.L2:
 144:main.c        ****   }
 145:main.c        ****   #else
 146:main.c        ****   // far jmp
 147:main.c        ****   if (currentAddress.w == RESET_VECTOR_OFFSET * 2) {
 148:main.c        ****     data = 0x940c;
 149:main.c        ****   } else if (currentAddress.w == (RESET_VECTOR_OFFSET +1 ) * 2) {
 150:main.c        ****     data = (BOOTLOADER_ADDRESS/2);
 151:main.c        ****   }    
 152:main.c        ****   #endif
 153:main.c        **** #endif
 154:main.c        **** 
 155:main.c        **** #if OSCCAL_SAVE_CALIB
 156:main.c        ****    if (currentAddress.w == BOOTLOADER_ADDRESS - TINYVECTOR_OSCCAL_OFFSET) {
 157:main.c        ****       data = OSCCAL;
 158:main.c        ****    }     
 159:main.c        **** #endif
 160:main.c        ****   
 161:main.c        ****   boot_page_fill(currentAddress.w, data);
 153               		.stabn	68,0,161,.LM3-.LFBB1
 154               	.LM3:
 155 000a 21E0      		ldi r18,lo8(1)
 156               	/* #APP */
 157               	 ;  161 "main.c" 1
 158 000c 0C01      		movw  r0, r24
 159 000e 2093 5700 		sts 87, r18
 160 0012 E895      		spm
 161 0014 1124      		clr  r1
 162               		
 163               	 ;  0 "" 2
 162:main.c        ****   currentAddress.w += 2;
 164               		.stabn	68,0,162,.LM4-.LFBB1
 165               	.LM4:
 166               	/* #NOAPP */
 167 0016 CF01      		movw r24,r30
 168 0018 0296      		adiw r24,2
 169 001a 2C01      		movw r4,r24
 170 001c 0895      		ret
 171               		.size	writeWordToPageBuffer, .-writeWordToPageBuffer
 172               	.Lscope1:
 173               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 174               		.stabd	78,0,0
 175               		.section	.text.initHardware,"ax",@progbits
 176               		.stabs	"initHardware:f(0,49)",36,0,191,initHardware
 177               		.type	initHardware, @function
 178               	initHardware:
 179               		.stabd	46,0,0
 163:main.c        **** }
GAS LISTING /tmp/cc4tR2OR.s 			page 7


 164:main.c        **** 
 165:main.c        **** /* ------------------------------------------------------------------------ */
 166:main.c        **** static uint8_t usbFunctionSetup(uint8_t data[8]) {
 167:main.c        ****   usbRequest_t *rq = (void *)data;
 168:main.c        ****  
 169:main.c        ****   if (rq->bRequest == cmd_device_info) { // get device info
 170:main.c        ****     usbMsgPtr = (usbMsgPtr_t)configurationReply;
 171:main.c        ****     return sizeof(configurationReply);      
 172:main.c        ****   } else if (rq->bRequest == cmd_transfer_page) { 
 173:main.c        ****       // Set page address. Address zero always has to be written first to ensure reset vector patch
 174:main.c        ****       // Mask to page boundary to prevent vulnerability to partial page write "attacks"
 175:main.c        ****         if ( currentAddress.w != 0 ) {
 176:main.c        ****             currentAddress.b[0]=rq->wIndex.bytes[0] & (~ (SPM_PAGESIZE-1));     
 177:main.c        ****             currentAddress.b[1]=rq->wIndex.bytes[1];     
 178:main.c        ****         }        
 179:main.c        ****     } else if (rq->bRequest == cmd_write_data) { // Write data
 180:main.c        ****       writeWordToPageBuffer(rq->wValue.word);
 181:main.c        ****       writeWordToPageBuffer(rq->wIndex.word);
 182:main.c        ****       if ((currentAddress.b[0] % SPM_PAGESIZE) == 0)
 183:main.c        ****           command=cmd_write_page; // ask runloop to write our page       
 184:main.c        ****   } else {
 185:main.c        ****     // Handle cmd_erase_application and cmd_exit
 186:main.c        ****     command=rq->bRequest&0x3f;    
 187:main.c        ****   }
 188:main.c        ****   return 0;
 189:main.c        **** }
 190:main.c        **** 
 191:main.c        **** static void initHardware (void)
 192:main.c        **** {
 180               		.stabn	68,0,192,.LM5-.LFBB2
 181               	.LM5:
 182               	.LFBB2:
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
 193:main.c        ****   // Disable watchdog and set timeout to maximum in case the WDT is fused on 
 194:main.c        **** #ifdef CCP
 195:main.c        ****   // New ATtinies841/441 use a different unlock sequence and renamed registers
 196:main.c        ****   MCUSR=0;    
 197:main.c        ****   CCP = 0xD8; 
 198:main.c        ****   WDTCSR = 1<<WDP2 | 1<<WDP1 | 1<<WDP0; 
 199:main.c        **** #else
 200:main.c        ****   MCUSR=0;    
 187               		.stabn	68,0,200,.LM6-.LFBB2
 188               	.LM6:
 189 0000 14BE      		out 0x34,__zero_reg__
 201:main.c        ****   WDTCR = 1<<WDCE | 1<<WDE;
 190               		.stabn	68,0,201,.LM7-.LFBB2
 191               	.LM7:
 192 0002 88E1      		ldi r24,lo8(24)
 193 0004 81BD      		out 0x21,r24
 202:main.c        ****   WDTCR = 1<<WDP2 | 1<<WDP1 | 1<<WDP0; 
 194               		.stabn	68,0,202,.LM8-.LFBB2
 195               	.LM8:
 196 0006 87E0      		ldi r24,lo8(7)
 197 0008 81BD      		out 0x21,r24
GAS LISTING /tmp/cc4tR2OR.s 			page 8


 203:main.c        **** #endif  
 204:main.c        **** 
 205:main.c        ****   
 206:main.c        ****   usbDeviceDisconnect();  /* do this while interrupts are disabled */
 198               		.stabn	68,0,206,.LM9-.LFBB2
 199               	.LM9:
 200 000a D39A      		sbi 0x1a,3
 201               	.LBB28:
 202               	.LBB29:
 203               		.stabs	"/usr/avr/include/util/delay.h",132,0,0,.Ltext1
 204               	.Ltext1:
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
GAS LISTING /tmp/cc4tR2OR.s 			page 9


  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
GAS LISTING /tmp/cc4tR2OR.s 			page 10


 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
GAS LISTING /tmp/cc4tR2OR.s 			page 11


 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 205               		.stabn	68,0,187,.LM10-.LFBB2
 206               	.LM10:
 207 000c 2FE7      		ldi r18,lo8(719999)
 208 000e 8CEF      		ldi r24,hi8(719999)
 209 0010 9AE0      		ldi r25,hlo8(719999)
 210 0012 2150      	1:	subi r18,1
 211 0014 8040      		sbci r24,0
 212 0016 9040      		sbci r25,0
 213 0018 01F4      		brne 1b
 214 001a 00C0      		rjmp .
 215 001c 0000      		nop
 216               	.LBE29:
 217               	.LBE28:
 218               		.stabs	"main.c",132,0,0,.Ltext2
 219               	.Ltext2:
 207:main.c        ****   _delay_ms(300);  
 208:main.c        ****   usbDeviceConnect();
 220               		.stabn	68,0,208,.LM11-.LFBB2
 221               	.LM11:
 222 001e D398      		cbi 0x1a,3
 223               	.LBB30:
 224               	.LBB31:
 225               		.stabs	"usbdrv/usbdrv.c",132,0,0,.Ltext3
 226               	.Ltext3:
   1:usbdrv/usbdrv.c **** /* Name: usbdrv.c
   2:usbdrv/usbdrv.c ****  * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3:usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   4:usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   5:usbdrv/usbdrv.c ****  * Tabsize: 4
   6:usbdrv/usbdrv.c ****  *
GAS LISTING /tmp/cc4tR2OR.s 			page 12


   7:usbdrv/usbdrv.c ****  
   8:usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   9:usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
  10:usbdrv/usbdrv.c ****  */
  11:usbdrv/usbdrv.c **** 
  12:usbdrv/usbdrv.c **** /* This copy of usbdrv.c was optimized to reduce the memory footprint with micronucleus V2
  13:usbdrv/usbdrv.c ****  *
  14:usbdrv/usbdrv.c ****  * Changes: 
  15:usbdrv/usbdrv.c ****  *     a) Replies to USB SETUP IN Packets are now only possible from Flash
  16:usbdrv/usbdrv.c ****  *       * Commented out routines to copy from SRAM
  17:usbdrv/usbdrv.c ****  *       * remove msgflag variable and all handling involving it
  18:usbdrv/usbdrv.c ****  */ 
  19:usbdrv/usbdrv.c **** #define MNHACK_ONLY_FLASH_MSGPTR                
  20:usbdrv/usbdrv.c **** /*     b) Do not use preinitialized global variables to avoid having to initialize
  21:usbdrv/usbdrv.c ****  *        the data section.
  22:usbdrv/usbdrv.c ****  */
  23:usbdrv/usbdrv.c **** #define MNHACK_NO_DATASECTION   
  24:usbdrv/usbdrv.c ****  
  25:usbdrv/usbdrv.c **** #include "usbdrv.h"
  26:usbdrv/usbdrv.c **** #include "oddebug.h"
  27:usbdrv/usbdrv.c **** 
  28:usbdrv/usbdrv.c **** /*
  29:usbdrv/usbdrv.c **** General Description:
  30:usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  31:usbdrv/usbdrv.c **** documentation of the entire driver.
  32:usbdrv/usbdrv.c **** */
  33:usbdrv/usbdrv.c **** 
  34:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  35:usbdrv/usbdrv.c **** 
  36:usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  37:usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
  38:usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  39:usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  40:usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  41:usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  42:usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  43:usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  44:usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  45:usbdrv/usbdrv.c **** #ifdef MNHACK_NO_DATASECTION
  46:usbdrv/usbdrv.c ****   volatile uchar usbTxLen;   /* number of bytes to transmit with next IN token or handshake token *
  47:usbdrv/usbdrv.c **** #else
  48:usbdrv/usbdrv.c ****   volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or hand
  49:usbdrv/usbdrv.c **** #endif
  50:usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  51:usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  52:usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  53:usbdrv/usbdrv.c **** #endif
  54:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
  55:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus1;
  56:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  57:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus3;
  58:usbdrv/usbdrv.c **** #   endif
  59:usbdrv/usbdrv.c **** #endif
  60:usbdrv/usbdrv.c **** #if USB_CFG_CHECK_DATA_TOGGLING
  61:usbdrv/usbdrv.c **** uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
  62:usbdrv/usbdrv.c **** #endif
  63:usbdrv/usbdrv.c **** 
GAS LISTING /tmp/cc4tR2OR.s 			page 13


  64:usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  65:usbdrv/usbdrv.c **** usbMsgPtr_t         usbMsgPtr;      /* data to transmit next -- ROM or RAM address */
  66:usbdrv/usbdrv.c **** #ifdef MNHACK_NO_DATASECTION
  67:usbdrv/usbdrv.c ****   static usbMsgLen_t  usbMsgLen; /* remaining number of bytes */
  68:usbdrv/usbdrv.c **** #else
  69:usbdrv/usbdrv.c ****   static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
  70:usbdrv/usbdrv.c **** #endif
  71:usbdrv/usbdrv.c ****   
  72:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR                
  73:usbdrv/usbdrv.c **** static uchar        usbMsgFlags;    /* flag values see below */
  74:usbdrv/usbdrv.c **** #endif
  75:usbdrv/usbdrv.c **** 
  76:usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  77:usbdrv/usbdrv.c **** #define USB_FLG_USE_USER_RW     (1<<7)
  78:usbdrv/usbdrv.c **** 
  79:usbdrv/usbdrv.c **** /*
  80:usbdrv/usbdrv.c **** optimizing hints:
  81:usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  82:usbdrv/usbdrv.c **** - assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
  83:usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  84:usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  85:usbdrv/usbdrv.c **** */
  86:usbdrv/usbdrv.c **** 
  87:usbdrv/usbdrv.c **** /* -------------------------- String Descriptors --------------------------- */
  88:usbdrv/usbdrv.c **** 
  89:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  90:usbdrv/usbdrv.c **** 
  91:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  92:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  93:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  94:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorString0[] = { /* language descriptor */
  95:usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  96:usbdrv/usbdrv.c ****     3,          /* descriptor type */
  97:usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  98:usbdrv/usbdrv.c **** };
  99:usbdrv/usbdrv.c **** #endif
 100:usbdrv/usbdrv.c **** 
 101:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
 102:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
 103:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
 104:usbdrv/usbdrv.c **** PROGMEM const int  usbDescriptorStringVendor[] = {
 105:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
 106:usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
 107:usbdrv/usbdrv.c **** };
 108:usbdrv/usbdrv.c **** #endif
 109:usbdrv/usbdrv.c **** 
 110:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
 111:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
 112:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
 113:usbdrv/usbdrv.c **** PROGMEM const int  usbDescriptorStringDevice[] = {
 114:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
 115:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
 116:usbdrv/usbdrv.c **** };
 117:usbdrv/usbdrv.c **** #endif
 118:usbdrv/usbdrv.c **** 
 119:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
 120:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
GAS LISTING /tmp/cc4tR2OR.s 			page 14


 121:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
 122:usbdrv/usbdrv.c **** PROGMEM const int usbDescriptorStringSerialNumber[] = {
 123:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
 124:usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
 125:usbdrv/usbdrv.c **** };
 126:usbdrv/usbdrv.c **** #endif
 127:usbdrv/usbdrv.c **** 
 128:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 129:usbdrv/usbdrv.c **** 
 130:usbdrv/usbdrv.c **** /* --------------------------- Device Descriptor --------------------------- */
 131:usbdrv/usbdrv.c **** 
 132:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
 133:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 134:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 135:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorDevice[] = {    /* USB device descriptor */
 136:usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 137:usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 138:usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 139:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 140:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 141:usbdrv/usbdrv.c ****     0,                      /* protocol */
 142:usbdrv/usbdrv.c ****     8,                      /* max packet size */
 143:usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 144:usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 145:usbdrv/usbdrv.c ****      */
 146:usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 147:usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 148:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 149:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 150:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 151:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
 152:usbdrv/usbdrv.c ****     1,          /* number of configurations */
 153:usbdrv/usbdrv.c **** };
 154:usbdrv/usbdrv.c **** #endif
 155:usbdrv/usbdrv.c **** 
 156:usbdrv/usbdrv.c **** /* ----------------------- Configuration Descriptor ------------------------ */
 157:usbdrv/usbdrv.c **** 
 158:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 159:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 160:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 161:usbdrv/usbdrv.c **** #endif
 162:usbdrv/usbdrv.c **** 
 163:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 164:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 165:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 166:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 167:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 168:usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 169:usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
 170:usbdrv/usbdrv.c ****                 (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 171:usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 172:usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 173:usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 174:usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 175:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 176:usbdrv/usbdrv.c ****     (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
 177:usbdrv/usbdrv.c **** #else
GAS LISTING /tmp/cc4tR2OR.s 			page 15


 178:usbdrv/usbdrv.c ****     (1 << 7),                           /* attributes */
 179:usbdrv/usbdrv.c **** #endif
 180:usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 181:usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 182:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 183:usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 184:usbdrv/usbdrv.c ****     0,          /* index of this interface */
 185:usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 186:usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of en
 187:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
 188:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
 189:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
 190:usbdrv/usbdrv.c ****     0,          /* string index for interface */
 191:usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 192:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 193:usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 194:usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 195:usbdrv/usbdrv.c ****     0x00,       /* target country code */
 196:usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 197:usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 198:usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 199:usbdrv/usbdrv.c **** #endif
 200:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 201:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 202:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 203:usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 204:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 205:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 206:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 207:usbdrv/usbdrv.c **** #endif
 208:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
 209:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 210:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 211:usbdrv/usbdrv.c ****     (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
 212:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 213:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 214:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 215:usbdrv/usbdrv.c **** #endif
 216:usbdrv/usbdrv.c **** };
 217:usbdrv/usbdrv.c **** #endif
 218:usbdrv/usbdrv.c **** 
 219:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 220:usbdrv/usbdrv.c **** 
 221:usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 222:usbdrv/usbdrv.c **** {
 223:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 224:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 225:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 226:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 227:usbdrv/usbdrv.c **** #   endif
 228:usbdrv/usbdrv.c **** #endif
 229:usbdrv/usbdrv.c **** }
 230:usbdrv/usbdrv.c **** 
 231:usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 232:usbdrv/usbdrv.c **** {
 233:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 234:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
GAS LISTING /tmp/cc4tR2OR.s 			page 16


 235:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 236:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 237:usbdrv/usbdrv.c **** #endif
 238:usbdrv/usbdrv.c **** #endif
 239:usbdrv/usbdrv.c **** }
 240:usbdrv/usbdrv.c **** 
 241:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 242:usbdrv/usbdrv.c **** 
 243:usbdrv/usbdrv.c **** #if !USB_CFG_SUPPRESS_INTR_CODE
 244:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 245:usbdrv/usbdrv.c **** static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
 246:usbdrv/usbdrv.c **** {
 247:usbdrv/usbdrv.c **** uchar   *p;
 248:usbdrv/usbdrv.c **** char    i;
 249:usbdrv/usbdrv.c **** 
 250:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 251:usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 252:usbdrv/usbdrv.c ****         return;
 253:usbdrv/usbdrv.c **** #endif
 254:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 255:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 256:usbdrv/usbdrv.c ****     }else{
 257:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 258:usbdrv/usbdrv.c ****     }
 259:usbdrv/usbdrv.c ****     p = txStatus->buffer + 1;
 260:usbdrv/usbdrv.c ****     i = len;
 261:usbdrv/usbdrv.c ****     do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
 262:usbdrv/usbdrv.c ****         *p++ = *data++;
 263:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 264:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 265:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 266:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 267:usbdrv/usbdrv.c **** }
 268:usbdrv/usbdrv.c **** 
 269:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 270:usbdrv/usbdrv.c **** {
 271:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus1);
 272:usbdrv/usbdrv.c **** }
 273:usbdrv/usbdrv.c **** #endif
 274:usbdrv/usbdrv.c **** 
 275:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 276:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
 277:usbdrv/usbdrv.c **** {
 278:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus3);
 279:usbdrv/usbdrv.c **** }
 280:usbdrv/usbdrv.c **** #endif
 281:usbdrv/usbdrv.c **** #endif /* USB_CFG_SUPPRESS_INTR_CODE */
 282:usbdrv/usbdrv.c **** 
 283:usbdrv/usbdrv.c **** /* ------------------ utilities for code following below ------------------- */
 284:usbdrv/usbdrv.c **** 
 285:usbdrv/usbdrv.c **** /* Use defines for the switch statement so that we can choose between an
 286:usbdrv/usbdrv.c ****  * if()else if() and a switch/case based implementation. switch() is more
 287:usbdrv/usbdrv.c ****  * efficient for a LARGE set of sequential choices, if() is better in all other
 288:usbdrv/usbdrv.c ****  * cases.
 289:usbdrv/usbdrv.c ****  */
 290:usbdrv/usbdrv.c **** #if USB_CFG_USE_SWITCH_STATEMENT
 291:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       switch(cmd){{
GAS LISTING /tmp/cc4tR2OR.s 			page 17


 292:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }break; case (value):{
 293:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
 294:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
 295:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }break; default:{
 296:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 297:usbdrv/usbdrv.c **** #else
 298:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
 299:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }else if(_cmd == (value)){
 300:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
 301:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || _cmd == (v3)){
 302:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }else{
 303:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 304:usbdrv/usbdrv.c **** #endif
 305:usbdrv/usbdrv.c **** 
 306:usbdrv/usbdrv.c **** #ifndef USB_RX_USER_HOOK
 307:usbdrv/usbdrv.c **** #define USB_RX_USER_HOOK(data, len)
 308:usbdrv/usbdrv.c **** #endif
 309:usbdrv/usbdrv.c **** #ifndef USB_SET_ADDRESS_HOOK
 310:usbdrv/usbdrv.c **** #define USB_SET_ADDRESS_HOOK()
 311:usbdrv/usbdrv.c **** #endif
 312:usbdrv/usbdrv.c **** 
 313:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 314:usbdrv/usbdrv.c **** 
 315:usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro below because #if can't be used
 316:usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 317:usbdrv/usbdrv.c ****  * This may cause problems with undefined symbols if compiled without
 318:usbdrv/usbdrv.c ****  * optimizing!
 319:usbdrv/usbdrv.c ****  */
 320:usbdrv/usbdrv.c **** 
 321:usbdrv/usbdrv.c ****   #define GET_DESCRIPTOR(cfgProp, staticName)         \
 322:usbdrv/usbdrv.c ****       if(cfgProp){                                    \
 323:usbdrv/usbdrv.c ****           if((cfgProp) & USB_PROP_IS_RAM)             \
 324:usbdrv/usbdrv.c ****               flags = 0;                              \
 325:usbdrv/usbdrv.c ****           if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 326:usbdrv/usbdrv.c ****               len = usbFunctionDescriptor(rq);        \
 327:usbdrv/usbdrv.c ****           }else{                                      \
 328:usbdrv/usbdrv.c ****               len = USB_PROP_LENGTH(cfgProp);         \
 329:usbdrv/usbdrv.c ****               usbMsgPtr = (usbMsgPtr_t)(staticName);  \
 330:usbdrv/usbdrv.c ****           }                                           \
 331:usbdrv/usbdrv.c ****       }
 332:usbdrv/usbdrv.c **** 
 333:usbdrv/usbdrv.c **** /* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 334:usbdrv/usbdrv.c ****  * internally for all types of descriptors.
 335:usbdrv/usbdrv.c ****  */
 336:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
 337:usbdrv/usbdrv.c **** {
 338:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 339:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 340:usbdrv/usbdrv.c **** 
 341:usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 342:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 343:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 344:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 345:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 346:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 347:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 348:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
GAS LISTING /tmp/cc4tR2OR.s 			page 18


 349:usbdrv/usbdrv.c ****             flags = 0;
 350:usbdrv/usbdrv.c ****         len = usbFunctionDescriptor(rq);
 351:usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 352:usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 353:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 354:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 355:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 356:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 357:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 358:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 359:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 360:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumbe
 361:usbdrv/usbdrv.c ****         SWITCH_DEFAULT
 362:usbdrv/usbdrv.c ****             if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 363:usbdrv/usbdrv.c ****                 len = usbFunctionDescriptor(rq);
 364:usbdrv/usbdrv.c ****             }
 365:usbdrv/usbdrv.c ****         SWITCH_END
 366:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 367:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 368:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 369:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 370:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 371:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 372:usbdrv/usbdrv.c **** #endif
 373:usbdrv/usbdrv.c ****     SWITCH_DEFAULT
 374:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 375:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);
 376:usbdrv/usbdrv.c ****         }
 377:usbdrv/usbdrv.c ****     SWITCH_END
 378:usbdrv/usbdrv.c ****     
 379:usbdrv/usbdrv.c ****     flags=flags;  // Make compiler shut up about unused variable
 380:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR                
 381:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 382:usbdrv/usbdrv.c **** #endif    
 383:usbdrv/usbdrv.c ****     return len;
 384:usbdrv/usbdrv.c **** }
 385:usbdrv/usbdrv.c **** 
 386:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 387:usbdrv/usbdrv.c **** 
 388:usbdrv/usbdrv.c **** /* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 389:usbdrv/usbdrv.c ****  * standard requests instead of class and custom requests.
 390:usbdrv/usbdrv.c ****  */
 391:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 392:usbdrv/usbdrv.c **** {
 393:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 394:usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 395:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 396:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 397:usbdrv/usbdrv.c **** uchar   index = rq->wIndex.bytes[0];
 398:usbdrv/usbdrv.c **** #endif
 399:usbdrv/usbdrv.c **** 
 400:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 401:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 402:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 403:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 404:usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 405:usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
GAS LISTING /tmp/cc4tR2OR.s 			page 19


 406:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 407:usbdrv/usbdrv.c ****         if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 408:usbdrv/usbdrv.c ****             dataPtr[0] = usbTxLen1 == USBPID_STALL;
 409:usbdrv/usbdrv.c **** #endif
 410:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 411:usbdrv/usbdrv.c ****         len = 2;
 412:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 413:usbdrv/usbdrv.c ****     SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 414:usbdrv/usbdrv.c ****         if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 415:usbdrv/usbdrv.c ****             usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
 416:usbdrv/usbdrv.c ****             usbResetDataToggling();
 417:usbdrv/usbdrv.c ****         }
 418:usbdrv/usbdrv.c **** #endif
 419:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 420:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 421:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 422:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 423:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 424:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 425:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 426:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 427:usbdrv/usbdrv.c ****         len = 1;
 428:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 429:usbdrv/usbdrv.c ****         usbConfiguration = value;
 430:usbdrv/usbdrv.c ****         usbResetStall();
 431:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 432:usbdrv/usbdrv.c ****         len = 1;
 433:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 434:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 435:usbdrv/usbdrv.c ****         usbResetDataToggling();
 436:usbdrv/usbdrv.c ****         usbResetStall();
 437:usbdrv/usbdrv.c **** #endif
 438:usbdrv/usbdrv.c ****     SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
 439:usbdrv/usbdrv.c ****         /* Should we add an optional hook here? */
 440:usbdrv/usbdrv.c ****     SWITCH_END
 441:usbdrv/usbdrv.c ****     usbMsgPtr = (usbMsgPtr_t)dataPtr;
 442:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 443:usbdrv/usbdrv.c ****     return len;
 444:usbdrv/usbdrv.c **** }
 445:usbdrv/usbdrv.c **** 
 446:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 447:usbdrv/usbdrv.c **** 
 448:usbdrv/usbdrv.c **** /* usbProcessRx() is called for every message received by the interrupt
 449:usbdrv/usbdrv.c ****  * routine. It distinguishes between SETUP and DATA packets and processes
 450:usbdrv/usbdrv.c ****  * them accordingly.
 451:usbdrv/usbdrv.c ****  */
 452:usbdrv/usbdrv.c **** static inline void usbProcessRx(uchar *data, uchar len)
 453:usbdrv/usbdrv.c **** {
 454:usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
 455:usbdrv/usbdrv.c **** 
 456:usbdrv/usbdrv.c **** /* usbRxToken can be:
 457:usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for setup data)
 458:usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 459:usbdrv/usbdrv.c ****  * 0...0x0f for OUT on endpoint X
 460:usbdrv/usbdrv.c ****  */
 461:usbdrv/usbdrv.c ****     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
 462:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
GAS LISTING /tmp/cc4tR2OR.s 			page 20


 463:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 464:usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 465:usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 466:usbdrv/usbdrv.c ****         return;
 467:usbdrv/usbdrv.c ****     }
 468:usbdrv/usbdrv.c **** #endif
 469:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 470:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 471:usbdrv/usbdrv.c ****             return;
 472:usbdrv/usbdrv.c ****         usbMsgLen_t replyLen;
 473:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 474:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 475:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 476:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 477:usbdrv/usbdrv.c **** #endif        
 478:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 479:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 480:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 481:usbdrv/usbdrv.c ****         }else{
 482:usbdrv/usbdrv.c ****             replyLen = usbDriverSetup(rq);
 483:usbdrv/usbdrv.c ****         }
 484:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 485:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 486:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 487:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 488:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 489:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 490:usbdrv/usbdrv.c ****                 }else{
 491:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.word;
 492:usbdrv/usbdrv.c ****                 }
 493:usbdrv/usbdrv.c ****             }
 494:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 495:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 496:usbdrv/usbdrv.c **** #endif
 497:usbdrv/usbdrv.c ****         if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
 498:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 499:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 500:usbdrv/usbdrv.c ****         }else{
 501:usbdrv/usbdrv.c ****             if(replyLen > rq->wLength.word)     /* limit length to max */
 502:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 503:usbdrv/usbdrv.c ****         }
 504:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 505:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 506:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 507:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 508:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 509:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 510:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 511:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 512:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 513:usbdrv/usbdrv.c ****             }
 514:usbdrv/usbdrv.c ****         }
 515:usbdrv/usbdrv.c **** #endif
 516:usbdrv/usbdrv.c ****     }
 517:usbdrv/usbdrv.c **** }
 518:usbdrv/usbdrv.c **** 
 519:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
GAS LISTING /tmp/cc4tR2OR.s 			page 21


 520:usbdrv/usbdrv.c **** 
 521:usbdrv/usbdrv.c **** /* This function is similar to usbFunctionRead(), but it's also called for
 522:usbdrv/usbdrv.c ****  * data handled automatically by the driver (e.g. descriptor reads).
 523:usbdrv/usbdrv.c ****  */
 524:usbdrv/usbdrv.c **** static uchar usbDeviceRead(uchar *data, uchar len)
 525:usbdrv/usbdrv.c **** {
 526:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 527:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 528:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 529:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 530:usbdrv/usbdrv.c ****         }else
 531:usbdrv/usbdrv.c **** #endif
 532:usbdrv/usbdrv.c ****         {
 533:usbdrv/usbdrv.c ****             uchar i = len;
 534:usbdrv/usbdrv.c ****             usbMsgPtr_t r = usbMsgPtr;
 535:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 536:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 537:usbdrv/usbdrv.c **** #endif          
 538:usbdrv/usbdrv.c ****                 do{
 539:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 540:usbdrv/usbdrv.c ****                     *data++ = c;
 541:usbdrv/usbdrv.c ****                     r++;
 542:usbdrv/usbdrv.c ****                 }while(--i);
 543:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 544:usbdrv/usbdrv.c ****              }else{  // RAM data 
 545:usbdrv/usbdrv.c ****                 do{
 546:usbdrv/usbdrv.c ****                     *data++ = *((uchar *)r);
 547:usbdrv/usbdrv.c ****                     r++;
 548:usbdrv/usbdrv.c ****                 }while(--i);
 549:usbdrv/usbdrv.c ****             }
 550:usbdrv/usbdrv.c **** #endif                      
 551:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 552:usbdrv/usbdrv.c ****         }
 553:usbdrv/usbdrv.c ****     }
 554:usbdrv/usbdrv.c ****     return len;
 555:usbdrv/usbdrv.c **** }
 556:usbdrv/usbdrv.c **** 
 557:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 558:usbdrv/usbdrv.c **** 
 559:usbdrv/usbdrv.c **** /* usbBuildTxBlock() is called when we have data to transmit and the
 560:usbdrv/usbdrv.c ****  * interrupt routine's transmit buffer is empty.
 561:usbdrv/usbdrv.c ****  */
 562:usbdrv/usbdrv.c **** static inline void usbBuildTxBlock(void)
 563:usbdrv/usbdrv.c **** {
 564:usbdrv/usbdrv.c **** usbMsgLen_t wantLen;
 565:usbdrv/usbdrv.c **** uchar       len;
 566:usbdrv/usbdrv.c **** 
 567:usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 568:usbdrv/usbdrv.c ****     if(wantLen > 8)
 569:usbdrv/usbdrv.c ****         wantLen = 8;
 570:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 571:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 572:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 573:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 574:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 575:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 576:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
GAS LISTING /tmp/cc4tR2OR.s 			page 22


 577:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 578:usbdrv/usbdrv.c ****     }else{
 579:usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 580:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 581:usbdrv/usbdrv.c ****     }
 582:usbdrv/usbdrv.c ****     usbTxLen = len;
 583:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 584:usbdrv/usbdrv.c **** }
 585:usbdrv/usbdrv.c **** 
 586:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 587:usbdrv/usbdrv.c **** 
 588:usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 589:usbdrv/usbdrv.c **** {
 590:usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 591:usbdrv/usbdrv.c **** static uchar    wasReset;
 592:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 593:usbdrv/usbdrv.c **** 
 594:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 595:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 596:usbdrv/usbdrv.c ****         wasReset = isReset;
 597:usbdrv/usbdrv.c ****     }
 598:usbdrv/usbdrv.c **** #else
 599:usbdrv/usbdrv.c ****     notResetState = notResetState;  // avoid compiler warning
 600:usbdrv/usbdrv.c **** #endif
 601:usbdrv/usbdrv.c **** }
 602:usbdrv/usbdrv.c **** 
 603:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 604:usbdrv/usbdrv.c **** 
 605:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 606:usbdrv/usbdrv.c **** {
 607:usbdrv/usbdrv.c **** schar   len;
 608:usbdrv/usbdrv.c **** uchar   i;
 609:usbdrv/usbdrv.c **** 
 610:usbdrv/usbdrv.c ****     len = usbRxLen - 3;
 611:usbdrv/usbdrv.c ****     if(len >= 0){
 612:usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 613:usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 614:usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
 615:usbdrv/usbdrv.c ****  * retries must be handled on application level.
 616:usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 617:usbdrv/usbdrv.c ****  */
 618:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 619:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 620:usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 621:usbdrv/usbdrv.c ****             usbRxLen = 0;
 622:usbdrv/usbdrv.c **** #else
 623:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 624:usbdrv/usbdrv.c **** #endif
 625:usbdrv/usbdrv.c ****     }
 626:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 627:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 628:usbdrv/usbdrv.c ****             usbBuildTxBlock();
 629:usbdrv/usbdrv.c ****         }
 630:usbdrv/usbdrv.c ****     }
 631:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 632:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 633:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
GAS LISTING /tmp/cc4tR2OR.s 			page 23


 634:usbdrv/usbdrv.c ****             goto isNotReset;
 635:usbdrv/usbdrv.c ****     }
 636:usbdrv/usbdrv.c ****     /* RESET condition, called multiple times during reset */
 637:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 638:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 639:usbdrv/usbdrv.c ****     usbResetStall();
 640:usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
 641:usbdrv/usbdrv.c **** isNotReset:
 642:usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 643:usbdrv/usbdrv.c **** }
 644:usbdrv/usbdrv.c **** 
 645:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 646:usbdrv/usbdrv.c **** 
 647:usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
 648:usbdrv/usbdrv.c **** {
 649:usbdrv/usbdrv.c **** #ifdef MNHACK_NO_DATASECTION   
 650:usbdrv/usbdrv.c ****     usbTxLen = USBPID_NAK;
 227               		.stabn	68,0,650,.LM12-.LFBB2
 228               	.LM12:
 229 0020 8AE5      		ldi r24,lo8(90)
 230 0022 8093 0000 		sts usbTxLen,r24
 651:usbdrv/usbdrv.c ****     usbMsgLen = USB_NO_MSG;
 231               		.stabn	68,0,651,.LM13-.LFBB2
 232               	.LM13:
 233 0026 8FEF      		ldi r24,lo8(-1)
 234 0028 8093 0000 		sts usbMsgLen,r24
 652:usbdrv/usbdrv.c **** #endif
 653:usbdrv/usbdrv.c ****     
 654:usbdrv/usbdrv.c **** #if USB_INTR_CFG_SET != 0
 655:usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 235               		.stabn	68,0,655,.LM14-.LFBB2
 236               	.LM14:
 237 002c 979A      		sbi 0x12,7
 656:usbdrv/usbdrv.c **** #endif
 657:usbdrv/usbdrv.c **** #if USB_INTR_CFG_CLR != 0
 658:usbdrv/usbdrv.c ****     USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
 659:usbdrv/usbdrv.c **** #endif
 660:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 238               		.stabn	68,0,660,.LM15-.LFBB2
 239               	.LM15:
 240 002e 8BB7      		in r24,0x3b
 241 0030 8061      		ori r24,lo8(16)
 242 0032 8BBF      		out 0x3b,r24
 243 0034 0895      		ret
 244               	.LBE31:
 245               	.LBE30:
 246               		.size	initHardware, .-initHardware
 247               	.Lscope2:
 248               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 249               		.stabd	78,0,0
 250               		.section	.text.startup.main,"ax",@progbits
 251               		.stabs	"main:F(0,1)",36,0,231,main
 252               	.global	main
 253               		.type	main, @function
 254               	main:
 255               		.stabd	46,0,0
 256               		.stabs	"main.c",132,0,0,.Ltext4
GAS LISTING /tmp/cc4tR2OR.s 			page 24


 257               	.Ltext4:
 209:main.c        **** 
 210:main.c        ****   usbInit();    // Initialize INT settings after reconnect
 211:main.c        **** }
 212:main.c        **** 
 213:main.c        **** /* ------------------------------------------------------------------------ */
 214:main.c        **** // reset system to a normal state and launch user program
 215:main.c        **** static void leaveBootloader(void) __attribute__((__noreturn__));
 216:main.c        **** static inline void leaveBootloader(void) {
 217:main.c        ****  
 218:main.c        ****   bootLoaderExit();
 219:main.c        **** 
 220:main.c        **** #if OSCCAL_RESTORE_DEFAULT
 221:main.c        ****   OSCCAL=osccal_default;
 222:main.c        ****   nop(); // NOP to avoid CPU hickup during oscillator stabilization
 223:main.c        **** #endif
 224:main.c        ****     
 225:main.c        ****  asm volatile ("rjmp __vectors - 4"); // jump to application reset vector at end of flash
 226:main.c        ****   
 227:main.c        ****  for (;;); // Make sure function does not return to help compiler optimize
 228:main.c        **** }
 229:main.c        **** 
 230:main.c        **** void USB_INTR_VECTOR(void);
 231:main.c        **** int main(void) {
 258               		.stabn	68,0,231,.LM16-.LFBB3
 259               	.LM16:
 260               	.LFBB3:
 261               	/* prologue: function */
 262               	/* frame size = 0 */
 263               	/* stack size = 0 */
 264               	.L__stack_usage = 0
 232:main.c        ****   uint8_t osccal_tmp;
 233:main.c        ****   
 234:main.c        ****   bootLoaderInit();
 235:main.c        ****   
 236:main.c        ****   /* save default OSCCAL calibration  */
 237:main.c        **** #if OSCCAL_RESTORE_DEFAULT
 238:main.c        ****   osccal_default = OSCCAL;
 239:main.c        **** #endif
 240:main.c        ****   
 241:main.c        **** #if OSCCAL_SAVE_CALIB
 242:main.c        ****   // adjust clock to previous calibration value, so bootloader starts with proper clock calibration
 243:main.c        ****   unsigned char stored_osc_calibration = pgm_read_byte(BOOTLOADER_ADDRESS - TINYVECTOR_OSCCAL_OFFSE
 244:main.c        ****   if (stored_osc_calibration != 0xFF) {
 245:main.c        ****     OSCCAL=stored_osc_calibration;
 246:main.c        ****     nop();
 247:main.c        ****   }
 248:main.c        **** #endif
 249:main.c        ****   
 250:main.c        ****   if (bootLoaderStartCondition()||(pgm_read_byte(BOOTLOADER_ADDRESS - TINYVECTOR_RESET_OFFSET + 1)=
 251:main.c        ****   
 252:main.c        ****     initHardware();        
 265               		.stabn	68,0,252,.LM17-.LFBB3
 266               	.LM17:
 267 0000 00D0      		rcall initHardware
 253:main.c        ****     LED_INIT();
 268               		.stabn	68,0,253,.LM18-.LFBB3
GAS LISTING /tmp/cc4tR2OR.s 			page 25


 269               	.LM18:
 270 0002 DA98      		cbi 0x1b,2
 254:main.c        **** 
 255:main.c        ****     if (AUTO_EXIT_NO_USB_MS>0) {
 256:main.c        ****       idlePolls.b[1]=((AUTO_EXIT_MS-AUTO_EXIT_NO_USB_MS)/5)>>8;
 257:main.c        ****     } else {
 258:main.c        ****       idlePolls.b[1]=0;
 271               		.stabn	68,0,258,.LM19-.LFBB3
 272               	.LM19:
 273 0004 712C      		mov r7,__zero_reg__
 259:main.c        ****     }
 260:main.c        ****     
 261:main.c        ****     command=cmd_local_nop;     
 274               		.stabn	68,0,261,.LM20-.LFBB3
 275               	.LM20:
 276 0006 312C      		mov r3,__zero_reg__
 262:main.c        ****     currentAddress.w = 0;
 277               		.stabn	68,0,262,.LM21-.LFBB3
 278               	.LM21:
 279 0008 412C      		mov r4,__zero_reg__
 280 000a 512C      		mov r5,__zero_reg__
 281               	.L44:
 231:main.c        ****   uint8_t osccal_tmp;
 282               		.stabn	68,0,231,.LM22-.LFBB3
 283               	.LM22:
 284 000c C0EA      		ldi r28,lo8(-96)
 285 000e DFE0      		ldi r29,lo8(15)
 286               	.LBB62:
 263:main.c        ****     
 264:main.c        ****     do {
 265:main.c        ****       // 15 clockcycles per loop.     
 266:main.c        ****       // adjust fastctr for 5ms timeout
 267:main.c        ****       
 268:main.c        ****       uint16_t fastctr=(uint16_t)(F_CPU/(1000.0f*15.0f/5.0f));
 269:main.c        ****       uint8_t  resetctr=100;
 287               		.stabn	68,0,269,.LM23-.LFBB3
 288               	.LM23:
 289 0010 84E6      		ldi r24,lo8(100)
 290               	.L10:
 270:main.c        ****   
 271:main.c        ****       do {        
 272:main.c        ****         if ((USBIN & USBMASK) !=0) resetctr=100;
 291               		.stabn	68,0,272,.LM24-.LFBB3
 292               	.LM24:
 293 0012 99B3      		in r25,0x19
 294 0014 9878      		andi r25,lo8(-120)
 295 0016 01F0      		breq .L6
 296 0018 84E6      		ldi r24,lo8(100)
 297               	.L6:
 273:main.c        ****         
 274:main.c        ****         if (!--resetctr) { // reset encountered
 298               		.stabn	68,0,274,.LM25-.LFBB3
 299               	.LM25:
 300 001a 8150      		subi r24,lo8(-(-1))
 301 001c 01F4      		brne .L7
 275:main.c        ****            usbNewDeviceAddr = 0;   // bits from the reset handling of usbpoll()
 302               		.stabn	68,0,275,.LM26-.LFBB3
GAS LISTING /tmp/cc4tR2OR.s 			page 26


 303               	.LM26:
 304 001e 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
 276:main.c        ****            usbDeviceAddr = 0;
 305               		.stabn	68,0,276,.LM27-.LFBB3
 306               	.LM27:
 307 0022 1092 0000 		sts usbDeviceAddr,__zero_reg__
 308               	.L7:
 277:main.c        **** #if (OSCCAL_HAVE_XTAL == 0)           
 278:main.c        ****            calibrateOscillatorASM();   
 279:main.c        **** #endif           
 280:main.c        ****         }
 281:main.c        ****         
 282:main.c        ****         if (USB_INTR_PENDING & (1<<USB_INTR_PENDING_BIT)) {
 309               		.stabn	68,0,282,.LM28-.LFBB3
 310               	.LM28:
 311 0026 0AB6      		in __tmp_reg__,0x3a
 312 0028 04FE      		sbrs __tmp_reg__,4
 313 002a 00C0      		rjmp .L8
 283:main.c        ****           USB_INTR_VECTOR();  
 314               		.stabn	68,0,283,.LM29-.LFBB3
 315               	.LM29:
 316 002c 00D0      		rcall __vector_2
 284:main.c        ****           USB_INTR_PENDING = 1<<USB_INTR_PENDING_BIT;  // Clear int pending, in case timeout occure
 317               		.stabn	68,0,284,.LM30-.LFBB3
 318               	.LM30:
 319 002e 80E1      		ldi r24,lo8(16)
 320 0030 8ABF      		out 0x3a,r24
 285:main.c        ****           idlePolls.b[1]=0; // reset idle polls when we get usb traffic
 321               		.stabn	68,0,285,.LM31-.LFBB3
 322               	.LM31:
 323 0032 712C      		mov r7,__zero_reg__
 286:main.c        ****          break;
 324               		.stabn	68,0,286,.LM32-.LFBB3
 325               	.LM32:
 326 0034 00C0      		rjmp .L9
 327               	.L8:
 328 0036 2197      		sbiw r28,1
 287:main.c        ****         }
 288:main.c        ****         
 289:main.c        ****       } while(--fastctr);     
 329               		.stabn	68,0,289,.LM33-.LFBB3
 330               	.LM33:
 331 0038 01F4      		brne .L10
 332               	.L9:
 290:main.c        ****       
 291:main.c        ****       wdr();
 333               		.stabn	68,0,291,.LM34-.LFBB3
 334               	.LM34:
 335               	/* #APP */
 336               	 ;  291 "main.c" 1
 337 003a A895      		wdr
 338               	 ;  0 "" 2
 292:main.c        ****       
 293:main.c        ****  #if OSCCAL_SLOW_PROGRAMMING
 294:main.c        ****       osccal_tmp  = OSCCAL;
 295:main.c        ****       OSCCAL      = osccal_default;
 296:main.c        ****  #endif
GAS LISTING /tmp/cc4tR2OR.s 			page 27


 297:main.c        ****       // commands are only evaluated after next USB transmission or after 5 ms passed
 298:main.c        ****       if (command==cmd_erase_application) 
 339               		.stabn	68,0,298,.LM35-.LFBB3
 340               	.LM35:
 341               	/* #NOAPP */
 342 003c 832D      		mov r24,r3
 343 003e 8230      		cpi r24,lo8(2)
 344 0040 01F4      		brne .L11
 345 0042 E0E4      		ldi r30,lo8(64)
 346 0044 FAE1      		ldi r31,lo8(26)
 347               	.L12:
 348               	.LBB63:
 349               	.LBB64:
 118:main.c        **** #endif    
 350               		.stabn	68,0,118,.LM36-.LFBB3
 351               	.LM36:
 352 0046 E054      		subi r30,64
 353 0048 F109      		sbc r31,__zero_reg__
 120:main.c        ****   }
 354               		.stabn	68,0,120,.LM37-.LFBB3
 355               	.LM37:
 356 004a 83E0      		ldi r24,lo8(3)
 357               	/* #APP */
 358               	 ;  120 "main.c" 1
 359 004c 8093 5700 		sts 87, r24
 360 0050 E895      		spm
 361               		
 362               	 ;  0 "" 2
 114:main.c        **** #if (defined __AVR_ATtiny841__)||(defined __AVR_ATtiny441__)    
 363               		.stabn	68,0,114,.LM38-.LFBB3
 364               	.LM38:
 365               	/* #NOAPP */
 366 0052 3097      		sbiw r30,0
 367 0054 01F4      		brne .L12
 124:main.c        **** }
 368               		.stabn	68,0,124,.LM39-.LFBB3
 369               	.LM39:
 370 0056 412C      		mov r4,__zero_reg__
 371 0058 512C      		mov r5,__zero_reg__
 372 005a 00C0      		rjmp .L13
 373               	.L11:
 374               	.LBE64:
 375               	.LBE63:
 299:main.c        ****         eraseApplication();
 300:main.c        ****       if (command==cmd_write_page) 
 376               		.stabn	68,0,300,.LM40-.LFBB3
 377               	.LM40:
 378 005c 8034      		cpi r24,lo8(64)
 379 005e 01F4      		brne .L14
 380               	.LBB65:
 381               	.LBB66:
 129:main.c        ****       boot_page_write(currentAddress.w - 2);   // will halt CPU, no waiting required
 382               		.stabn	68,0,129,.LM41-.LFBB3
 383               	.LM41:
 384 0060 F201      		movw r30,r4
 385 0062 3297      		sbiw r30,2
 386 0064 E034      		cpi r30,64
GAS LISTING /tmp/cc4tR2OR.s 			page 28


 387 0066 2AE1      		ldi r18,26
 388 0068 F207      		cpc r31,r18
 389 006a 00F4      		brsh .L13
 130:main.c        **** }
 390               		.stabn	68,0,130,.LM42-.LFBB3
 391               	.LM42:
 392 006c 85E0      		ldi r24,lo8(5)
 393               	/* #APP */
 394               	 ;  130 "main.c" 1
 395 006e 8093 5700 		sts 87, r24
 396 0072 E895      		spm
 397               		
 398               	 ;  0 "" 2
 399               	/* #NOAPP */
 400 0074 00C0      		rjmp .L13
 401               	.L14:
 402               	.LBE66:
 403               	.LBE65:
 301:main.c        ****         writeFlashPage();          
 302:main.c        ****  #if OSCCAL_SLOW_PROGRAMMING
 303:main.c        ****       OSCCAL      = osccal_tmp;
 304:main.c        ****  #endif
 305:main.c        ****         
 306:main.c        ****       if (command==cmd_exit) {
 404               		.stabn	68,0,306,.LM43-.LFBB3
 405               	.LM43:
 406 0076 8430      		cpi r24,lo8(4)
 407 0078 01F4      		brne .L13
 307:main.c        ****         if (!fastctr) break;  // Only exit after 5 ms timeout     
 408               		.stabn	68,0,307,.LM44-.LFBB3
 409               	.LM44:
 410 007a CD2B      		or r28,r29
 411 007c 01F4      		brne .L16
 412 007e 00C0      		rjmp .L15
 413               	.L13:
 308:main.c        ****       } else {
 309:main.c        ****         command=cmd_local_nop;     
 414               		.stabn	68,0,309,.LM45-.LFBB3
 415               	.LM45:
 416 0080 312C      		mov r3,__zero_reg__
 417               	.L16:
 418               	.LBB67:
 310:main.c        ****       }  
 311:main.c        ****  
 312:main.c        ****       {
 313:main.c        ****       // This is usbpoll() minus reset logic and double buffering
 314:main.c        ****         int8_t  len;
 315:main.c        ****         len = usbRxLen - 3;
 419               		.stabn	68,0,315,.LM46-.LFBB3
 420               	.LM46:
 421 0082 8091 0000 		lds r24,usbRxLen
 422 0086 8350      		subi r24,lo8(-(-3))
 316:main.c        ****         
 317:main.c        ****         if(len >= 0){
 423               		.stabn	68,0,317,.LM47-.LFBB3
 424               	.LM47:
 425 0088 87FD      		sbrc r24,7
GAS LISTING /tmp/cc4tR2OR.s 			page 29


 426 008a 00C0      		rjmp .L17
 427               	.LBB68:
 428               	.LBB69:
 429               		.stabs	"usbdrv/usbdrv.c",132,0,0,.Ltext5
 430               	.Ltext5:
 469:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 431               		.stabn	68,0,469,.LM48-.LFBB3
 432               	.LM48:
 433 008c 9091 0000 		lds r25,usbRxToken
 434 0090 9D32      		cpi r25,lo8(45)
 435 0092 01F0      		breq .+2
 436 0094 00C0      		rjmp .L18
 437               	.LBB70:
 470:usbdrv/usbdrv.c ****             return;
 438               		.stabn	68,0,470,.LM49-.LFBB3
 439               	.LM49:
 440 0096 8830      		cpi r24,lo8(8)
 441 0098 01F0      		breq .+2
 442 009a 00C0      		rjmp .L18
 473:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 443               		.stabn	68,0,473,.LM50-.LFBB3
 444               	.LM50:
 445 009c 83EC      		ldi r24,lo8(-61)
 446 009e 8093 0000 		sts usbTxBuf,r24
 474:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 447               		.stabn	68,0,474,.LM51-.LFBB3
 448               	.LM51:
 449 00a2 8AE5      		ldi r24,lo8(90)
 450 00a4 8093 0000 		sts usbTxLen,r24
 479:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 451               		.stabn	68,0,479,.LM52-.LFBB3
 452               	.LM52:
 453 00a8 8091 0000 		lds r24,usbRxBuf+1
 454 00ac 8076      		andi r24,lo8(96)
 455 00ae 9091 0000 		lds r25,usbRxBuf+2
 456 00b2 8823      		tst r24
 457 00b4 01F0      		breq .L19
 458               	.LBB71:
 459               	.LBB72:
 460               		.stabs	"main.c",132,0,0,.Ltext6
 461               	.Ltext6:
 169:main.c        ****     usbMsgPtr = (usbMsgPtr_t)configurationReply;
 462               		.stabn	68,0,169,.LM53-.LFBB3
 463               	.LM53:
 464 00b6 9111      		cpse r25,__zero_reg__
 465 00b8 00C0      		rjmp .L20
 170:main.c        ****     return sizeof(configurationReply);      
 466               		.stabn	68,0,170,.LM54-.LFBB3
 467               	.LM54:
 468 00ba 80E0      		ldi r24,lo8(configurationReply)
 469 00bc 90E0      		ldi r25,hi8(configurationReply)
 470 00be 9093 0000 		sts usbMsgPtr+1,r25
 471 00c2 8093 0000 		sts usbMsgPtr,r24
 171:main.c        ****   } else if (rq->bRequest == cmd_transfer_page) { 
 472               		.stabn	68,0,171,.LM55-.LFBB3
 473               	.LM55:
 474 00c6 86E0      		ldi r24,lo8(6)
GAS LISTING /tmp/cc4tR2OR.s 			page 30


 475 00c8 00C0      		rjmp .L21
 476               	.L20:
 172:main.c        ****       // Set page address. Address zero always has to be written first to ensure reset vector patch
 477               		.stabn	68,0,172,.LM56-.LFBB3
 478               	.LM56:
 479 00ca 9130      		cpi r25,lo8(1)
 480 00cc 01F4      		brne .L22
 175:main.c        ****             currentAddress.b[0]=rq->wIndex.bytes[0] & (~ (SPM_PAGESIZE-1));     
 481               		.stabn	68,0,175,.LM57-.LFBB3
 482               	.LM57:
 483 00ce 4114      		cp r4,__zero_reg__
 484 00d0 5104      		cpc r5,__zero_reg__
 485 00d2 01F0      		breq .L72
 176:main.c        ****             currentAddress.b[1]=rq->wIndex.bytes[1];     
 486               		.stabn	68,0,176,.LM58-.LFBB3
 487               	.LM58:
 488 00d4 8091 0000 		lds r24,usbRxBuf+5
 489 00d8 807C      		andi r24,lo8(-64)
 490 00da 482E      		mov r4,r24
 177:main.c        ****         }        
 491               		.stabn	68,0,177,.LM59-.LFBB3
 492               	.LM59:
 493 00dc 5090 0000 		lds r5,usbRxBuf+6
 494 00e0 00C0      		rjmp .L72
 495               	.L22:
 179:main.c        ****       writeWordToPageBuffer(rq->wValue.word);
 496               		.stabn	68,0,179,.LM60-.LFBB3
 497               	.LM60:
 498 00e2 9330      		cpi r25,lo8(3)
 499 00e4 01F4      		brne .L24
 180:main.c        ****       writeWordToPageBuffer(rq->wIndex.word);
 500               		.stabn	68,0,180,.LM61-.LFBB3
 501               	.LM61:
 502 00e6 8091 0000 		lds r24,usbRxBuf+3
 503 00ea 9091 0000 		lds r25,usbRxBuf+3+1
 504 00ee 00D0      		rcall writeWordToPageBuffer
 181:main.c        ****       if ((currentAddress.b[0] % SPM_PAGESIZE) == 0)
 505               		.stabn	68,0,181,.LM62-.LFBB3
 506               	.LM62:
 507 00f0 8091 0000 		lds r24,usbRxBuf+5
 508 00f4 9091 0000 		lds r25,usbRxBuf+5+1
 509 00f8 00D0      		rcall writeWordToPageBuffer
 182:main.c        ****           command=cmd_write_page; // ask runloop to write our page       
 510               		.stabn	68,0,182,.LM63-.LFBB3
 511               	.LM63:
 512 00fa 842D      		mov r24,r4
 513 00fc 8F73      		andi r24,lo8(63)
 514 00fe 01F4      		brne .L72
 183:main.c        ****   } else {
 515               		.stabn	68,0,183,.LM64-.LFBB3
 516               	.LM64:
 517 0100 90E4      		ldi r25,lo8(64)
 518 0102 392E      		mov r3,r25
 519 0104 00C0      		rjmp .L21
 520               	.L24:
 186:main.c        ****   }
 521               		.stabn	68,0,186,.LM65-.LFBB3
GAS LISTING /tmp/cc4tR2OR.s 			page 31


 522               	.LM65:
 523 0106 9F73      		andi r25,lo8(63)
 524 0108 392E      		mov r3,r25
 525               	.L72:
 188:main.c        **** }
 526               		.stabn	68,0,188,.LM66-.LFBB3
 527               	.LM66:
 528 010a 80E0      		ldi r24,0
 529 010c 00C0      		rjmp .L21
 530               	.L19:
 531               	.LBE72:
 532               	.LBE71:
 533               	.LBB73:
 534               	.LBB74:
 535               		.stabs	"usbdrv/usbdrv.c",132,0,0,.Ltext7
 536               	.Ltext7:
 395:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 537               		.stabn	68,0,395,.LM67-.LFBB3
 538               	.LM67:
 539 010e 8091 0000 		lds r24,usbRxBuf+3
 400:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 540               		.stabn	68,0,400,.LM68-.LFBB3
 541               	.LM68:
 542 0112 1092 0000 		sts usbTxBuf+9,__zero_reg__
 543               	.LBB75:
 402:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 544               		.stabn	68,0,402,.LM69-.LFBB3
 545               	.LM69:
 546 0116 9111      		cpse r25,__zero_reg__
 547 0118 00C0      		rjmp .L26
 548               	.LBB76:
 410:usbdrv/usbdrv.c ****         len = 2;
 549               		.stabn	68,0,410,.LM70-.LFBB3
 550               	.LM70:
 551 011a 1092 0000 		sts usbTxBuf+10,__zero_reg__
 552               	.LBE76:
 553               	.LBE75:
 394:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 554               		.stabn	68,0,394,.LM71-.LFBB3
 555               	.LM71:
 556 011e 20E0      		ldi r18,lo8(usbTxBuf+9)
 557 0120 30E0      		ldi r19,hi8(usbTxBuf+9)
 558               	.LBB83:
 559               	.LBB77:
 411:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 560               		.stabn	68,0,411,.LM72-.LFBB3
 561               	.LM72:
 562 0122 82E0      		ldi r24,lo8(2)
 563 0124 00C0      		rjmp .L27
 564               	.L26:
 565               	.LBE77:
 419:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 566               		.stabn	68,0,419,.LM73-.LFBB3
 567               	.LM73:
 568 0126 9530      		cpi r25,lo8(5)
 569 0128 01F4      		brne .L28
 420:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
GAS LISTING /tmp/cc4tR2OR.s 			page 32


 570               		.stabn	68,0,420,.LM74-.LFBB3
 571               	.LM74:
 572 012a 8093 0000 		sts usbNewDeviceAddr,r24
 573 012e 00C0      		rjmp .L70
 574               	.L28:
 422:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 575               		.stabn	68,0,422,.LM75-.LFBB3
 576               	.LM75:
 577 0130 9630      		cpi r25,lo8(6)
 578 0132 01F4      		brne .L29
 579 0134 9091 0000 		lds r25,usbRxBuf+4
 580               	.LBB78:
 581               	.LBB79:
 582               	.LBB80:
 342:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 583               		.stabn	68,0,342,.LM76-.LFBB3
 584               	.LM76:
 585 0138 9130      		cpi r25,lo8(1)
 586 013a 01F4      		brne .L30
 343:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 587               		.stabn	68,0,343,.LM77-.LFBB3
 588               	.LM77:
 589 013c 80E0      		ldi r24,lo8(usbDescriptorDevice)
 590 013e 90E0      		ldi r25,hi8(usbDescriptorDevice)
 591 0140 00C0      		rjmp .L71
 592               	.L30:
 344:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 593               		.stabn	68,0,344,.LM78-.LFBB3
 594               	.LM78:
 595 0142 9230      		cpi r25,lo8(2)
 596 0144 01F4      		brne .L31
 345:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 597               		.stabn	68,0,345,.LM79-.LFBB3
 598               	.LM79:
 599 0146 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 600 0148 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 601               	.L71:
 602 014a 9093 0000 		sts usbMsgPtr+1,r25
 603 014e 8093 0000 		sts usbMsgPtr,r24
 604 0152 82E1      		ldi r24,lo8(18)
 605 0154 00C0      		rjmp .L21
 606               	.L31:
 346:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 607               		.stabn	68,0,346,.LM80-.LFBB3
 608               	.LM80:
 609 0156 9330      		cpi r25,lo8(3)
 610 0158 01F4      		brne .L72
 611               	.LBB81:
 353:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 612               		.stabn	68,0,353,.LM81-.LFBB3
 613               	.LM81:
 614 015a 8111      		cpse r24,__zero_reg__
 615 015c 00C0      		rjmp .L72
 354:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 616               		.stabn	68,0,354,.LM82-.LFBB3
 617               	.LM82:
 618 015e 80E0      		ldi r24,lo8(usbDescriptorString0)
GAS LISTING /tmp/cc4tR2OR.s 			page 33


 619 0160 90E0      		ldi r25,hi8(usbDescriptorString0)
 620 0162 9093 0000 		sts usbMsgPtr+1,r25
 621 0166 8093 0000 		sts usbMsgPtr,r24
 622 016a 84E0      		ldi r24,lo8(4)
 623 016c 00C0      		rjmp .L21
 624               	.L29:
 625               	.LBE81:
 626               	.LBE80:
 627               	.LBE79:
 628               	.LBE78:
 425:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 629               		.stabn	68,0,425,.LM83-.LFBB3
 630               	.LM83:
 631 016e 9830      		cpi r25,lo8(8)
 632 0170 01F0      		breq .L47
 428:usbdrv/usbdrv.c ****         usbConfiguration = value;
 633               		.stabn	68,0,428,.LM84-.LFBB3
 634               	.LM84:
 635 0172 9930      		cpi r25,lo8(9)
 636 0174 01F4      		brne .L32
 429:usbdrv/usbdrv.c ****         usbResetStall();
 637               		.stabn	68,0,429,.LM85-.LFBB3
 638               	.LM85:
 639 0176 8093 0000 		sts usbConfiguration,r24
 640               	.L70:
 641               	.LBE83:
 394:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 642               		.stabn	68,0,394,.LM86-.LFBB3
 643               	.LM86:
 644 017a 20E0      		ldi r18,lo8(usbTxBuf+9)
 645 017c 30E0      		ldi r19,hi8(usbTxBuf+9)
 393:usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 646               		.stabn	68,0,393,.LM87-.LFBB3
 647               	.LM87:
 648 017e 80E0      		ldi r24,0
 649 0180 00C0      		rjmp .L27
 650               	.L32:
 651               	.LBB84:
 652               	.LBB82:
 411:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 653               		.stabn	68,0,411,.LM88-.LFBB3
 654               	.LM88:
 655 0182 81E0      		ldi r24,lo8(1)
 656 0184 9A30      		cpi r25,lo8(10)
 657 0186 01F0      		breq .L33
 658 0188 80E0      		ldi r24,0
 659               	.L33:
 660               	.LBE82:
 661               	.LBE84:
 394:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 662               		.stabn	68,0,394,.LM89-.LFBB3
 663               	.LM89:
 664 018a 20E0      		ldi r18,lo8(usbTxBuf+9)
 665 018c 30E0      		ldi r19,hi8(usbTxBuf+9)
 666 018e 00C0      		rjmp .L27
 667               	.L47:
 668               	.LBB85:
GAS LISTING /tmp/cc4tR2OR.s 			page 34


 426:usbdrv/usbdrv.c ****         len = 1;
 669               		.stabn	68,0,426,.LM90-.LFBB3
 670               	.LM90:
 671 0190 20E0      		ldi r18,lo8(usbConfiguration)
 672 0192 30E0      		ldi r19,hi8(usbConfiguration)
 427:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 673               		.stabn	68,0,427,.LM91-.LFBB3
 674               	.LM91:
 675 0194 81E0      		ldi r24,lo8(1)
 676               	.L27:
 677               	.LBE85:
 441:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 678               		.stabn	68,0,441,.LM92-.LFBB3
 679               	.LM92:
 680 0196 3093 0000 		sts usbMsgPtr+1,r19
 681 019a 2093 0000 		sts usbMsgPtr,r18
 682               	.L21:
 683               	.LBE74:
 684               	.LBE73:
 498:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 685               		.stabn	68,0,498,.LM93-.LFBB3
 686               	.LM93:
 687 019e 9091 0000 		lds r25,usbRxBuf+8
 688 01a2 9111      		cpse r25,__zero_reg__
 689 01a4 00C0      		rjmp .L34
 690 01a6 9091 0000 		lds r25,usbRxBuf+7
 691 01aa 9817      		cp r25,r24
 692 01ac 00F4      		brsh .L34
 693 01ae 892F      		mov r24,r25
 694               	.L34:
 504:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 695               		.stabn	68,0,504,.LM94-.LFBB3
 696               	.LM94:
 697 01b0 8093 0000 		sts usbMsgLen,r24
 698               	.L18:
 699               	.LBE70:
 700               	.LBE69:
 701               	.LBE68:
 702               		.stabs	"main.c",132,0,0,.Ltext8
 703               	.Ltext8:
 318:main.c        ****             usbProcessRx(usbRxBuf + 1, len); // only single buffer due to in-order processing
 319:main.c        ****             usbRxLen = 0;       /* mark rx buffer as available */
 704               		.stabn	68,0,319,.LM95-.LFBB3
 705               	.LM95:
 706 01b4 1092 0000 		sts usbRxLen,__zero_reg__
 707               	.L17:
 320:main.c        ****         }
 321:main.c        ****         
 322:main.c        ****         if(usbTxLen & 0x10){    /* transmit system idle */
 708               		.stabn	68,0,322,.LM96-.LFBB3
 709               	.LM96:
 710 01b8 8091 0000 		lds r24,usbTxLen
 711 01bc 84FF      		sbrs r24,4
 712 01be 00C0      		rjmp .L36
 323:main.c        ****             if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 713               		.stabn	68,0,323,.LM97-.LFBB3
 714               	.LM97:
GAS LISTING /tmp/cc4tR2OR.s 			page 35


 715 01c0 8091 0000 		lds r24,usbMsgLen
 716 01c4 8F3F      		cpi r24,lo8(-1)
 717 01c6 01F0      		breq .L36
 718 01c8 C82F      		mov r28,r24
 719 01ca 8930      		cpi r24,lo8(9)
 720 01cc 00F0      		brlo .L37
 721 01ce C8E0      		ldi r28,lo8(8)
 722               	.L37:
 723               	.LBB86:
 724               	.LBB87:
 725               		.stabs	"usbdrv/usbdrv.c",132,0,0,.Ltext9
 726               	.Ltext9:
 570:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 727               		.stabn	68,0,570,.LM98-.LFBB3
 728               	.LM98:
 729 01d0 8C1B      		sub r24,r28
 730 01d2 8093 0000 		sts usbMsgLen,r24
 571:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 731               		.stabn	68,0,571,.LM99-.LFBB3
 732               	.LM99:
 733 01d6 9091 0000 		lds r25,usbTxBuf
 734 01da 88E8      		ldi r24,lo8(-120)
 735 01dc 8927      		eor r24,r25
 736 01de 8093 0000 		sts usbTxBuf,r24
 737               	.LBB88:
 738               	.LBB89:
 526:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 739               		.stabn	68,0,526,.LM100-.LFBB3
 740               	.LM100:
 741 01e2 CC23      		tst r28
 742 01e4 01F0      		breq .L38
 743               	.LBB90:
 534:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 744               		.stabn	68,0,534,.LM101-.LFBB3
 745               	.LM101:
 746 01e6 E091 0000 		lds r30,usbMsgPtr
 747 01ea F091 0000 		lds r31,usbMsgPtr+1
 748 01ee A0E0      		ldi r26,lo8(usbTxBuf+1)
 749 01f0 B0E0      		ldi r27,hi8(usbTxBuf+1)
 750 01f2 8C2F      		mov r24,r28
 751               	.L39:
 752               	.LBB91:
 753               	.LBB92:
 539:usbdrv/usbdrv.c ****                     *data++ = c;
 754               		.stabn	68,0,539,.LM102-.LFBB3
 755               	.LM102:
 756               	/* #APP */
 757               	 ;  539 "usbdrv/usbdrv.c" 1
 758 01f4 9491      		lpm r25, Z
 759               		
 760               	 ;  0 "" 2
 761               	/* #NOAPP */
 762               	.LBE92:
 540:usbdrv/usbdrv.c ****                     r++;
 763               		.stabn	68,0,540,.LM103-.LFBB3
 764               	.LM103:
 765 01f6 9D93      		st X+,r25
GAS LISTING /tmp/cc4tR2OR.s 			page 36


 541:usbdrv/usbdrv.c ****                 }while(--i);
 766               		.stabn	68,0,541,.LM104-.LFBB3
 767               	.LM104:
 768 01f8 3196      		adiw r30,1
 769               	.LBE91:
 542:usbdrv/usbdrv.c **** #ifndef MNHACK_ONLY_FLASH_MSGPTR            
 770               		.stabn	68,0,542,.LM105-.LFBB3
 771               	.LM105:
 772 01fa 8150      		subi r24,lo8(-(-1))
 773 01fc 01F4      		brne .L39
 551:usbdrv/usbdrv.c ****         }
 774               		.stabn	68,0,551,.LM106-.LFBB3
 775               	.LM106:
 776 01fe F093 0000 		sts usbMsgPtr+1,r31
 777 0202 E093 0000 		sts usbMsgPtr,r30
 778               	.L38:
 779               	.LBE90:
 780               	.LBE89:
 781               	.LBE88:
 574:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 782               		.stabn	68,0,574,.LM107-.LFBB3
 783               	.LM107:
 784 0206 6C2F      		mov r22,r28
 785 0208 80E0      		ldi r24,lo8(usbTxBuf+1)
 786 020a 90E0      		ldi r25,hi8(usbTxBuf+1)
 787 020c 00D0      		rcall usbCrc16Append
 575:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 788               		.stabn	68,0,575,.LM108-.LFBB3
 789               	.LM108:
 790 020e CC5F      		subi r28,lo8(-(4))
 576:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 791               		.stabn	68,0,576,.LM109-.LFBB3
 792               	.LM109:
 793 0210 CC30      		cpi r28,lo8(12)
 794 0212 01F0      		breq .L40
 577:usbdrv/usbdrv.c ****     }else{
 795               		.stabn	68,0,577,.LM110-.LFBB3
 796               	.LM110:
 797 0214 8FEF      		ldi r24,lo8(-1)
 798 0216 8093 0000 		sts usbMsgLen,r24
 799               	.L40:
 582:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 800               		.stabn	68,0,582,.LM111-.LFBB3
 801               	.LM111:
 802 021a C093 0000 		sts usbTxLen,r28
 803               	.L36:
 804               	.LBE87:
 805               	.LBE86:
 806               	.LBE67:
 807               		.stabs	"main.c",132,0,0,.Ltext10
 808               	.Ltext10:
 324:main.c        ****                 usbBuildTxBlock();
 325:main.c        ****             }
 326:main.c        ****         }
 327:main.c        ****       }
 328:main.c        ****       
 329:main.c        ****       idlePolls.w++;
GAS LISTING /tmp/cc4tR2OR.s 			page 37


 809               		.stabn	68,0,329,.LM112-.LFBB3
 810               	.LM112:
 811 021e C301      		movw r24,r6
 812 0220 0196      		adiw r24,1
 813 0222 3C01      		movw r6,r24
 330:main.c        **** 
 331:main.c        ****       // Try to execute program when bootloader times out      
 332:main.c        ****       if (AUTO_EXIT_MS&&(idlePolls.w==(AUTO_EXIT_MS/5))) {
 814               		.stabn	68,0,332,.LM113-.LFBB3
 815               	.LM113:
 816 0224 803B      		cpi r24,-80
 817 0226 9440      		sbci r25,4
 818 0228 01F4      		brne .L41
 819               	.LBB93:
 333:main.c        ****          if (pgm_read_byte(BOOTLOADER_ADDRESS - TINYVECTOR_RESET_OFFSET + 1)!=0xff)  break;
 820               		.stabn	68,0,333,.LM114-.LFBB3
 821               	.LM114:
 822 022a EDE3      		ldi r30,lo8(61)
 823 022c FAE1      		ldi r31,lo8(26)
 824               	/* #APP */
 825               	 ;  333 "main.c" 1
 826 022e E491      		lpm r30, Z
 827               		
 828               	 ;  0 "" 2
 829               	/* #NOAPP */
 830               	.LBE93:
 831 0230 EF3F      		cpi r30,lo8(-1)
 832 0232 01F4      		brne .L15
 833               	.L41:
 334:main.c        ****       }
 335:main.c        ****       
 336:main.c        ****       LED_MACRO( idlePolls.b[0] );   
 834               		.stabn	68,0,336,.LM115-.LFBB3
 835               	.LM115:
 836 0234 862D      		mov r24,r6
 837 0236 8C74      		andi r24,lo8(76)
 838 0238 01F0      		breq .L42
 839               		.stabn	68,0,336,.LM116-.LFBB3
 840               	.LM116:
 841 023a D298      		cbi 0x1a,2
 842 023c 00C0      		rjmp .L43
 843               	.L42:
 844               		.stabn	68,0,336,.LM117-.LFBB3
 845               	.LM117:
 846 023e D29A      		sbi 0x1a,2
 847               	.L43:
 337:main.c        **** 
 338:main.c        ****        // Test whether another interrupt occurred during the processing of USBpoll and commands.
 339:main.c        ****        // If yes, we missed a data packet on the bus. Wait until the bus was idle for 8.8s to 
 340:main.c        ****        // allow synchronising to the next incoming packet. 
 341:main.c        ****        
 342:main.c        ****        if (USB_INTR_PENDING & (1<<USB_INTR_PENDING_BIT))  // Usbpoll() collided with data packet
 848               		.stabn	68,0,342,.LM118-.LFBB3
 849               	.LM118:
 850 0240 0AB6      		in __tmp_reg__,0x3a
 851 0242 04FE      		sbrs __tmp_reg__,4
 852 0244 00C0      		rjmp .L44
GAS LISTING /tmp/cc4tR2OR.s 			page 38


 853               	.LBB94:
 343:main.c        ****        {        
 344:main.c        ****           uint8_t ctr;
 345:main.c        ****          
 346:main.c        ****           // loop takes 5 cycles
 347:main.c        ****           asm volatile(      
 854               		.stabn	68,0,347,.LM119-.LFBB3
 855               	.LM119:
 856               	/* #APP */
 857               	 ;  347 "main.c" 1
 858 0246 85E1      		         ldi  r24,21 
 859 0248 CB9B      		loop488:  sbis 25,3  
 860 024a 85E1      		         ldi  r24,21  
 861 024c 8150      		         subi r24,1   
 862 024e 01F4      		         brne loop488 
 863               		
 864               	 ;  0 "" 2
 348:main.c        ****           "         ldi  %0,%1 \n\t"        
 349:main.c        ****           "loop%=:  sbis %2,%3  \n\t"        
 350:main.c        ****           "         ldi  %0,%1  \n\t"
 351:main.c        ****           "         subi %0,1   \n\t"        
 352:main.c        ****           "         brne loop%= \n\t"   
 353:main.c        ****           : "=&d" (ctr)
 354:main.c        ****           :  "M" ((uint8_t)(8.8f*(F_CPU/1.0e6f)/5.0f+0.5)), "I" (_SFR_IO_ADDR(USBIN)), "M" (USB_CFG
 355:main.c        ****           );       
 356:main.c        ****          USB_INTR_PENDING = 1<<USB_INTR_PENDING_BIT;                   
 865               		.stabn	68,0,356,.LM120-.LFBB3
 866               	.LM120:
 867               	/* #NOAPP */
 868 0250 80E1      		ldi r24,lo8(16)
 869 0252 8ABF      		out 0x3a,r24
 870 0254 00C0      		rjmp .L44
 871               	.L15:
 872               	.LBE94:
 873               	.LBE62:
 357:main.c        ****        }                        
 358:main.c        ****     } while(1);  
 359:main.c        **** 
 360:main.c        ****     LED_EXIT();
 874               		.stabn	68,0,360,.LM121-.LFBB3
 875               	.LM121:
 876 0256 D298      		cbi 0x1a,2
 361:main.c        ****     
 362:main.c        ****     initHardware();  /* Disconnect micronucleus */    
 877               		.stabn	68,0,362,.LM122-.LFBB3
 878               	.LM122:
 879 0258 00D0      		rcall initHardware
 363:main.c        ****     
 364:main.c        ****     USB_INTR_ENABLE = 0;
 880               		.stabn	68,0,364,.LM123-.LFBB3
 881               	.LM123:
 882 025a 1BBE      		out 0x3b,__zero_reg__
 365:main.c        ****     USB_INTR_CFG = 0;       /* also reset config bits */
 883               		.stabn	68,0,365,.LM124-.LFBB3
 884               	.LM124:
 885 025c 12BA      		out 0x12,__zero_reg__
 886               	.LBB95:
GAS LISTING /tmp/cc4tR2OR.s 			page 39


 887               	.LBB96:
 225:main.c        ****   
 888               		.stabn	68,0,225,.LM125-.LFBB3
 889               	.LM125:
 890               	/* #APP */
 891               	 ;  225 "main.c" 1
 892 025e 00C0      		rjmp __vectors - 4
 893               	 ;  0 "" 2
 894               	/* #NOAPP */
 895               	.L46:
 896 0260 00C0      		rjmp .L46
 897               	.LBE96:
 898               	.LBE95:
 899               		.size	main, .-main
 900               		.stabs	"fastctr:r(5,4)",64,0,268,28
 901               		.stabs	"resetctr:r(5,2)",64,0,269,24
 902               		.stabn	192,0,0,.LBB62-.LFBB3
 903               		.stabs	"ptr:r(5,4)",64,0,112,30
 904               		.stabn	192,0,0,.LBB64-.LFBB3
 905               		.stabn	224,0,0,.LBE64-.LFBB3
 906               		.stabs	"dataPtr:r(0,54)=*(0,13)",64,0,394,18
 907               		.stabs	"value:r(0,13)",64,0,395,24
 908               		.stabn	192,0,0,.LBB74-.LFBB3
 909               		.stabs	"_cmd:r(0,13)",64,0,341,25
 910               		.stabn	192,0,0,.LBB80-.LFBB3
 911               		.stabn	224,0,0,.LBE80-.LFBB3
 912               		.stabn	224,0,0,.LBE74-.LFBB3
 913               		.stabs	"len:r(0,13)",64,0,565,28
 914               		.stabn	192,0,0,.LBB87-.LFBB3
 915               		.stabs	"r:r(0,54)",64,0,534,30
 916               		.stabn	192,0,0,.LBB90-.LFBB3
 917               		.stabn	224,0,0,.LBE90-.LFBB3
 918               		.stabn	224,0,0,.LBE87-.LFBB3
 919               		.stabn	224,0,0,.LBE62-.LFBB3
 920               	.Lscope3:
 921               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 922               		.stabd	78,0,0
 923               	.global	configurationReply
 924               		.section	.progmem.data.configurationReply,"a",@progbits
 925               		.type	configurationReply, @object
 926               		.size	configurationReply, 6
 927               	configurationReply:
 928 0000 1A        		.byte	26
 929 0001 3A        		.byte	58
 930 0002 40        		.byte	64
 931 0003 05        		.byte	5
 932 0004 93        		.byte	-109
 933 0005 0C        		.byte	12
 934               	.global	usbDescriptorConfiguration
 935               		.section	.progmem.data.usbDescriptorConfiguration,"a",@progbits
 936               		.type	usbDescriptorConfiguration, @object
 937               		.size	usbDescriptorConfiguration, 18
 938               	usbDescriptorConfiguration:
 939 0000 09        		.byte	9
 940 0001 02        		.byte	2
 941 0002 12        		.byte	18
 942 0003 00        		.byte	0
GAS LISTING /tmp/cc4tR2OR.s 			page 40


 943 0004 01        		.byte	1
 944 0005 01        		.byte	1
 945 0006 00        		.byte	0
 946 0007 80        		.byte	-128
 947 0008 32        		.byte	50
 948 0009 09        		.byte	9
 949 000a 04        		.byte	4
 950 000b 00        		.byte	0
 951 000c 00        		.byte	0
 952 000d 00        		.byte	0
 953 000e 00        		.byte	0
 954 000f 00        		.byte	0
 955 0010 00        		.byte	0
 956 0011 00        		.byte	0
 957               	.global	usbDescriptorDevice
 958               		.section	.progmem.data.usbDescriptorDevice,"a",@progbits
 959               		.type	usbDescriptorDevice, @object
 960               		.size	usbDescriptorDevice, 18
 961               	usbDescriptorDevice:
 962 0000 12        		.byte	18
 963 0001 01        		.byte	1
 964 0002 10        		.byte	16
 965 0003 01        		.byte	1
 966 0004 FF        		.byte	-1
 967 0005 00        		.byte	0
 968 0006 00        		.byte	0
 969 0007 08        		.byte	8
 970 0008 D0        		.byte	-48
 971 0009 16        		.byte	22
 972 000a 53        		.byte	83
 973 000b 07        		.byte	7
 974 000c 01        		.byte	1
 975 000d 02        		.byte	2
 976 000e 00        		.byte	0
 977 000f 00        		.byte	0
 978 0010 00        		.byte	0
 979 0011 01        		.byte	1
 980               	.global	usbDescriptorString0
 981               		.section	.progmem.data.usbDescriptorString0,"a",@progbits
 982               		.type	usbDescriptorString0, @object
 983               		.size	usbDescriptorString0, 4
 984               	usbDescriptorString0:
 985 0000 04        		.byte	4
 986 0001 03        		.byte	3
 987 0002 09        		.byte	9
 988 0003 04        		.byte	4
 989               		.section	.bss.usbMsgLen,"aw",@nobits
 990               		.type	usbMsgLen, @object
 991               		.size	usbMsgLen, 1
 992               	usbMsgLen:
 993 0000 00        		.zero	1
 994               		.comm	usbMsgPtr,2,1
 995               		.comm	usbTxBuf,11,1
 996               		.comm	usbTxLen,1,1
 997               		.comm	usbRxToken,1,1
 998               		.comm	usbCurrentTok,1,1
 999               		.comm	usbRxLen,1,1
GAS LISTING /tmp/cc4tR2OR.s 			page 41


 1000               		.comm	usbConfiguration,1,1
 1001               		.comm	usbNewDeviceAddr,1,1
 1002               		.comm	usbDeviceAddr,1,1
 1003               		.comm	usbInputBufOffset,1,1
 1004               		.comm	usbRxBuf,22,1
 1005               		.stabs	"usbMsgLen:S(0,13)",40,0,67,usbMsgLen
 1006               		.stabs	"usbMsgPtr:G(0,54)",32,0,65,0
 1007               		.stabs	"usbRxToken:G(0,13)",32,0,44,0
 1008               		.stabs	"usbConfiguration:G(0,13)",32,0,41,0
 1009               		.stabs	"usbDescriptorDevice:G(0,55)=ar(13,4);0;17;(0,56)=k(0,2)",32,0,135,0
 1010               		.stabs	"usbDescriptorConfiguration:G(0,55)",32,0,166,0
 1011               		.stabs	"usbDescriptorString0:G(0,57)=ar(13,4);0;3;(0,56)",32,0,94,0
 1012               		.stabs	"usbRxBuf:G(0,58)=ar(13,4);0;21;(0,13)",32,0,37,0
 1013               		.stabs	"usbInputBufOffset:G(0,13)",32,0,38,0
 1014               		.stabs	"usbDeviceAddr:G(0,13)",32,0,39,0
 1015               		.stabs	"usbNewDeviceAddr:G(0,13)",32,0,40,0
 1016               		.stabs	"usbRxLen:G(0,59)=B(0,12)",32,0,42,0
 1017               		.stabs	"usbCurrentTok:G(0,13)",32,0,43,0
 1018               		.stabs	"usbTxLen:G(13,2)",32,0,46,0
 1019               		.stabs	"usbTxBuf:G(13,3)",32,0,50,0
 1020               		.stabs	"configurationReply:G(0,60)=ar(13,4);0;5;(0,61)=k(5,2)",32,0,56,0
 1021               		.stabs	"currentAddress:r(0,50)",64,0,74,4
 1022               		.stabs	"idlePolls:r(0,50)",64,0,75,6
 1023               		.stabs	"command:r(5,2)",64,0,87,3
 1024               		.text
 1025               		.stabs	"",100,0,0,.Letext0
 1026               	.Letext0:
 1027               		.ident	"GCC: (GNU) 5.3.0"
 1028               	.global __do_clear_bss
GAS LISTING /tmp/cc4tR2OR.s 			page 42


DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc4tR2OR.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc4tR2OR.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc4tR2OR.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc4tR2OR.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc4tR2OR.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc4tR2OR.s:134    .text.writeWordToPageBuffer:0000000000000000 writeWordToPageBuffer
     /tmp/cc4tR2OR.s:178    .text.initHardware:0000000000000000 initHardware
                            *COM*:0000000000000001 usbTxLen
     /tmp/cc4tR2OR.s:992    .bss.usbMsgLen:0000000000000000 usbMsgLen
     /tmp/cc4tR2OR.s:254    .text.startup.main:0000000000000000 main
                            *COM*:0000000000000001 usbNewDeviceAddr
                            *COM*:0000000000000001 usbDeviceAddr
                            *COM*:0000000000000001 usbRxLen
                            *COM*:0000000000000001 usbRxToken
                            *COM*:000000000000000b usbTxBuf
                            *COM*:0000000000000016 usbRxBuf
     /tmp/cc4tR2OR.s:927    .progmem.data.configurationReply:0000000000000000 configurationReply
                            *COM*:0000000000000002 usbMsgPtr
     /tmp/cc4tR2OR.s:961    .progmem.data.usbDescriptorDevice:0000000000000000 usbDescriptorDevice
     /tmp/cc4tR2OR.s:938    .progmem.data.usbDescriptorConfiguration:0000000000000000 usbDescriptorConfiguration
     /tmp/cc4tR2OR.s:984    .progmem.data.usbDescriptorString0:0000000000000000 usbDescriptorString0
                            *COM*:0000000000000001 usbConfiguration
     /tmp/cc4tR2OR.s:859    .text.startup.main:0000000000000248 loop488
                            *COM*:0000000000000001 usbCurrentTok
                            *COM*:0000000000000001 usbInputBufOffset

UNDEFINED SYMBOLS
__vector_2
usbCrc16Append
__vectors
__do_clear_bss
